[{"title":"使用Vue搭建博客（三）——前端文章渲染","date":"2017-10-23T12:30:45.000Z","path":"2017/10/23/使用Vue搭建博客（三）/","text":"首先从服务器请求articles数据，并使用vuex管理 article-list.vue组件中引入articles的Getter，然后使用v-for 将 articles 渲染一遍就行 1234567891011//article-list.vue&lt;article v-for=\"(item, index) in articles\" key=&#123;index&#125; class=\"typo\"&gt; &lt;div class=\"cover\" :style=\"&#123;backgroundImage: ``&#125;\"&gt;&lt;/div&gt; &lt;header&gt; &lt;h2 @click=\"readMore(item)\"&gt;&#123;&#123;item.title&#125;&#125;&lt;/h2&gt; &lt;h4&gt;&#123;&#123;new Date(item.time).toLocaleString()&#125;&#125;&lt;/h4&gt; &lt;/header&gt; &lt;div v-html=\"item.abstract\" class=\"article-content\"&gt; &lt;/div&gt; &lt;footer @click=\"readMore(item)\"&gt;继续阅读&lt;/footer&gt;&lt;/article&gt; 1234567export default &#123; computed: &#123; ...mapGetters([ 'articles' ]) &#125;&#125; 接下来就是书写 article 的样式了。不过需要注意的一点是如果 style 使用了 scoped ，那么v-html中的被渲染的那一部分是不能被scoped中的css选择符匹配的。 也就是说不能这样写 1234567&lt;style lang=\"less\" scoped&gt; .article-content &#123; p &#123; /*这个样式将不生效*/ margin-bottom: 1.5em; &#125; &#125;&lt;/style&gt; 而是应该这样写 1234567&lt;style lang=\"less\"&gt; .article-content &#123; p &#123; margin-bottom: 1.5em; &#125; &#125;&lt;/style&gt; 其实文章详情组件article.vue书写方式和article-list.vue也差不多， 只不过 article-content 的v-html内容从abstract(文章概括)变成了content(正文) 12345678910111213//article.vue&lt;article class=\"typo\"&gt; &lt;div class=\"cover\" :style=\"&#123;backgroundImage: `url($&#123;bgImg&#125;)`&#125;\"&gt;&lt;/div&gt; &lt;header&gt; &lt;h2&gt;&#123;&#123;currentArticle &amp;&amp; currentArticle.title&#125;&#125;&lt;/h2&gt; &lt;h4&gt;&#123;&#123;currentArticle.time &amp;&amp; new Date(currentArticle.time).toLocaleString()&#125;&#125;&lt;/h4&gt; &lt;p class=\"tag\"&gt; &lt;span v-for=\"(tag, index) in currentArticle.tags\"&gt;&#123;&#123;tag&#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;/header&gt; &lt;div v-html=\"currentArticle &amp;&amp; currentArticle.content\" class=\"article-content\" ref=\"content\"&gt; &lt;/div&gt;&lt;/article&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"使用Vue搭建博客（二）——后端进行Markdown解析","date":"2017-10-23T10:45:02.000Z","path":"2017/10/23/使用Vue搭建博客（二）/","text":"后台搭建代码忽略不计， 核心就是将markdown文本解析成HTML，然后保存进mongodb就行 blog的数据结构（使用Mongodb）其中content字段是存储转换过后的HTML文档，contentMD字段是存储原生Markdown文档 123456789101112131415161718192021222324var &#123; mongoose &#125; = require('./connect');var Schema = mongoose.Schema;var articleSchema = new Schema(&#123; author: String, title: String, time: Date, updateTime: Date, abstract: String, tags: Array, content: String, // 转换过后的html contentMD: String // markdown&#125;);var tagSchema = new Schema (&#123; blogid: &#123;type: mongoose.Schema.Types.ObjectId, ref: 'articles'&#125;, tag: &#123;type: String&#125;, blogTime: Date, blogTitle: String&#125;);var Blog = mongoose.model('articles',articleSchema);var Tag = mongoose.model('tags', tagSchema)exports.Tag = Tag;exports.Blog = Blog; 使用marked进行Markdown渲染并将结果保存到Mongodbmarked使用方式https://github.com/chjj/marked 请忽略糟糕的回调 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173var &#123; Blog, Tag &#125; = require('../mongo/blog');var marked = require('marked');var renderer = new marked.Renderer();var ObjectId = require('mongoose').Types.ObjectId;renderer.heading = function (text, level) &#123; var escapedText = text return '&lt;h' + level + '&gt;&lt;a name=\"' + escapedText + '\" class=\"anchor\" href=\"#' + escapedText + '\"&gt;&lt;span class=\"header-link\"&gt;&lt;/span&gt;&lt;/a&gt;' + text + '&lt;/h' + level + '&gt;';&#125;,marked.setOptions(&#123; renderer: renderer, gfm: true, tables: true, breaks: false, pedantic: false, sanitize: false, smartLists: true, smartypants: false, highlight: function (code) &#123; return require('highlight.js').highlightAuto(code).value; &#125;&#125;);exports.mdparser = function (&#123;md, article&#125;, callback) &#123; /* * --- title: 一份完整的express4后台配置 date: 2017-09-21 11:01:28 tags: [nodeJS, express] --- */ // 解析 如上的文章头部 let title,time,tags // md表示hexo格式的原生md文档, article 表示直接传入的是一个article对象 // 如果只有md,没有article, 则表示通过上传的方式传入文章解析到的md文档（一般为hexo生成的markdown， 具有如上的文章头部信息） // 如果只有article, 没有md ,则表示第一次创建该文章是通过博客的admin页面在线创建、或者修改 if (!article &amp;&amp; md) &#123; let hrlen = '---'.length; let contentIndex = md.indexOf('---',md.indexOf('---') + hrlen) + hrlen // 正文开始的index let desc = md.slice(0, contentIndex); // 文件头部 title = desc.match(/title:(.*)/)[1]; time = desc.match(/date:(.*)/)[1]; tags = desc.match(/tags:(.*)/)[1].replace(/[\\[\\]]/g,'').trim(); if (tags === '') &#123; tags = [] &#125; else &#123; tags = tags.split(',') &#125; if (title.length &lt;= 0 &amp;&amp; time.length &lt;= 0) &#123; callback &amp;&amp; callback(&#123;status: 'err', err: 'cannot parse article'&#125;) return &#125; md = md.slice(contentIndex); &#125; else if (article)&#123; md = article.contentMD; title = article.title; tags = article.tags; time = article.time || new Date(); &#125; else &#123; callback &amp;&amp; callback(&#123;status: 'err', err: 'both Object article and markdown file are invalid'&#125;) return &#125; marked(md, function(err, html) &#123; if(err) &#123; callback &amp;&amp; callback (&#123;status: 'err', err: err&#125;); return &#125; // 提取解析后文档 &lt;!--more--&gt; 之前的部分,左右abstract let more = html.match(/&lt;!--\\s*(more)\\s*--&gt;/); let moreIndex = 0; let abstract = ''; if(more!==null) &#123; moreIndex = more.index; abstract = html.slice(0, moreIndex) &#125; // 到这儿已经解析完毕， 剩下的操作就是将解析的HTML存放到Mongodb if(!err) &#123; // 如果已经有该blog， 则更新，没有则创建 Blog.findOneAndUpdate(&#123; title: title, &#125;,&#123; title: title, time: new Date(time), content: html, abstract: abstract, tags: tags, contentMD: md &#125;,&#123; upsert: true // if not exist , create the object &#125;, function (err, doc) &#123; let promises = []; if(err) &#123; callback &amp;&amp; callback(&#123;status: 'err', err: err&#125;); return &#125; if(!doc) &#123; Blog.findOne(&#123;title: title&#125;, (err, doc2) =&gt; &#123; let promises = [] if(tags.length &lt;= 0) &#123; callback &amp;&amp; callback(&#123;status: 'ok', warnning: 'no tag', msg: 'created'&#125;) return &#125; tags.forEach((item, index) =&gt; &#123; let data = &#123; tag: item, blogid: new ObjectId(doc2._id), blogTitle: doc2.title, blogTime: doc2.time &#125; // 如果tag数据没有变动，则数据维持原样 let promise = new Promise((resolve, reject) =&gt; &#123; Tag.findOneAndUpdate(data/*query*/,data/*update*/,&#123;upsert: true&#125;,(err) =&gt; &#123; if(err) &#123; console.log('Tag save error: ' + err); reject(&#123;status: 'err', err: err&#125;) return &#125; else &#123; resolve(&#123;status: 'ok', msg: 'created'&#125;) &#125; &#125;) &#125;) promises.push(promise) &#125;) Promise.all(promises).then((messages) =&gt; &#123; callback &amp;&amp; callback(&#123;status: 'ok', msg: 'created'&#125;) &#125;).catch((err) =&gt; &#123; callback &amp;&amp; callback(&#123;status: 'err', err: err&#125;) &#125;) &#125;) return; &#125; if(tags.length &lt;= 0) &#123; callback &amp;&amp; callback(&#123;status: 'ok', warnning: 'no tag', msg: 'updated'&#125;) return &#125; tags.forEach((item, index) =&gt; &#123; let data = &#123; tag: item, blogid: new ObjectId(doc._id), blogTitle: doc.title, blogTime: doc.time &#125; let promise = new Promise((resolve, reject) =&gt; &#123; // 如果tag数据没有变动，则数据维持原样 Tag.findOneAndUpdate(data/*query*/,data/*update*/,&#123;upsert: true&#125;,(err) =&gt; &#123; if(err) &#123; console.log('Tag save error: ' + err); reject(&#123;status: 'err', err: err&#125;) return &#125; else &#123; resolve(&#123;status: 'ok', msg: 'updated'&#125;) &#125; &#125;) &#125;) promises.push(promise) &#125;) Promise.all(promises).then((messages) =&gt; &#123; callback &amp;&amp; callback(&#123;status: 'ok', msg: 'updated'&#125;) &#125;).catch(err =&gt; &#123; console.log(err) callback &amp;&amp; callback(&#123;status: 'err', err: err&#125;) &#125;) &#125;) &#125; &#125;)&#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"使用Vue搭建博客（一）——项目初始化","date":"2017-10-23T09:58:30.000Z","path":"2017/10/23/使用Vue搭建博客（一）/","text":"使用Vue-cli构建项目，然后在src目录建立相应文件夹 目录结构大概如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768├── dist //dist│ ├── index.html│ └── m-index.html├── package.json├── package-lock.json├── README.md└── src ├── api //api接口的请求代码 │ ├── api.js │ └── host.js ├── common //公共代码 │ ├── js │ │ ├── dom.js //部分DOM操作，包含滚动和初始化目录 │ ├── less │ │ ├── code-theme-dracula.css // Markdown 代码主题 │ │ └── variable.less // less变量 │ ├── reset.css // reset │ └── typo.css // 文本排版css ├── components │ ├── about //关于 │ │ ├── about-m.vue // -m表示移动端组件 │ │ └── about.vue │ ├── archive //归档（标签页面） │ │ ├── archive-m.vue │ │ └── archive.vue │ ├── article //文章展示界面 │ │ ├── article-m.vue │ │ └── article.vue │ ├── article-list //文章列表 │ │ ├── article-list-m.vue │ │ └── article-list.vue │ ├── back-top //回到顶部 │ │ ├── back-top-m.vue │ │ └── back-top.vue │ ├── comment //评论组件 │ │ └── comment.vue │ ├── header //顶部 │ │ ├── header-m.vue │ │ └── header.vue │ ├── main //main组件 │ │ ├── main-m.vue │ │ └── main.vue │ ├── scrollbar //滚动条组件 │ │ └── scrollbar.vue │ └── search //搜索页面 │ ├── search-m.vue │ └── search.vue ├── pages //分别存放移动端入口文件和PC端入口文件 │ ├── index │ │ ├── App.vue │ │ ├── assets │ │ ├── index.html │ │ ├── index.js //入口文件 │ │ ├── router //路由 │ │ └── store //vuex │ └── m-index │ ├── App.vue │ ├── assets │ ├── m-index.html │ ├── m-index.js //入口文件 │ ├── router │ └── store └── store //Vuex公共代码 ├── getters.js ├── index.js ├── mutations.js ├── mutation-types.js └── state.js 这个项目构建方式和vue-cli的默认构建方式有差别，原因是我要写两套界面（一套桌面端和一套移动端），而两套界面有一些公共的代码。 使用vue-cli构建多页面参考http://www.jianshu.com/p/0a30aca71b16","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"记录一下博客后台搭建过程","date":"2017-10-20T05:02:11.000Z","path":"2017/10/20/记录一下博客后台搭建过程/","text":"本地项目开发完毕，如何部署到服务器却成了难题，如果不熟悉Linux那简直是遭罪 做个搭建记录，万一以后又用上了呢 这一切都建立在已经有域名并且已经解析到服务器的前提下 拷贝文件到服务器本地写完nodejs过后，将这些后台代码和网页静态文件一并拷贝到服务器 可以使用scp、ftp、rsync等。 感觉还是rsync最方便1234rsync -av --exclude 'node_modules' 本地文件 root@服务器地址:远程主机文件夹如：rsync -av --exclude 'node_modules' ~/blog/ root@xxx:/var/www/blog/ 服务器安装mongodb并导入mongodb数据安装mongodb https://docs.mongodb.com/manual/tutorial/install-mongodb-on-debian/ 我用的是debian8， 所以采用的是debian8 的安装方式 依次执行下面代码就行了 1sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 1echo \"deb http://repo.mongodb.org/apt/debian jessie/mongodb-org/3.4 main\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list 1sudo apt update 1sudo apt-get install -y mongodb-org 为mongodb启用验证创建用户1.首先使用mongo命令进入mongodb，然后创建一个admin 用户 1use admin 12345678db.createUser(&#123; user: \"admin\", pwd: \"password\", roles[&#123; role: \"userAdminAnyDatabase\", db: \"admin\" &#125;]&#125;) 2.检查创建是否生效， 如果结果是1， 则表示创建的用户能被授权成功 1db.auth(\"admin\", \"password\") 然后使用exit退出 3.开启授权 1sudo vi /etc/mongod.conf 将security一行取消注释，并在下方添加上authorization: enable 12security: authorization: enabled 4.重启并检查重启是否成功 12[sudo] service mongod restart[sudo] service mongod status 5.使用创建好的admin用户登录并创建新用户给blog数据库 1234567use admindb.auth(\"admin\", \"adminpassword\")use blogdb.createUser(&#123; user: \"blogAdmin\", pwd: \"xxx\", roles: [&#123; role: \"readWrite\", db: \"blog\" &#125;] &#125;db.auth(\"blogAdmin\", \"xxx\") nodejs中使用的连接方式 mongodb://youruser:yourpassword@localhost/yourdatabase 导入导出mongodb数据本地开发完毕后，需要将mongodb数据导出，然后将数据拷贝到服务器 本地导出, 在终端输入命令([]表示可省略)1mongodump [-h IP --port 端口] -u 用户名 -p 密码 -d 数据库 -o 导出文件路径 将导出的文件夹使用rsync一并拷贝到服务器， 然后导入。 注意导入的数据库是服务器创建的某个数据库名字，不一定要和本地开发时用的数据库名字一样；导入数据时一定要先创建好数据库 1mongorestore [-h IP --port 端口] -u 用户名 -p 密码 -d 数据库 --drop 导入文件路径 服务器安装nginx 对Node.js进行端口映射通常时候一个服务器会跑很多Node.js程序，监听的端口一般都不是80，而是8888， 9999什么的，毕竟80端口只有一个，不可能随便给的。然而客户端访问网页的时候通常都是使用80或者443端口。这时候就需要端口nginx 搭配 Node.js做端口映射了 1.安装 1[sudo] apt install nginx 2.编辑配置文件，向http里面添加如下配置 123456789101112131415161718192021222324server &#123; listen 80; server_name blog.linyqiang.com; rewrite ^(.*)$ https://$host$1 permanent;&#125;server &#123; listen 443 ssl; ssl_certificate /etc/letsencrypt/live/blog.linyqiang.com/fullchain.pem; # 使用letsencrypt生成的crt ssl_certificate_key /etc/letsencrypt/live/blog.linyqiang.com/privkey.pem; # 生成的key server_name blog.linyqiang.com; # 域名 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1; location / &#123; proxy_pass https://127.0.0.1:8889; # Node.js服务器地址及端口 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_set_header X-Forward-Proto https; proxy_http_version 1.1; # for websocket proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; &#125;&#125; 然后在服务端启动程序123cd /var/www/blogpm2 start app.js --max-memory-restart 100M 这时候就可以通过服务器ip + Node.js监听port方式访问了，比如浏览器输入 http://123.123.123.123:8888 使用Let’s Encrypt 证书毕竟小绿锁看起来还是很舒服的 可以使用certbot快速生成证书。如果觉得命令行操作起来麻烦， 可以使用一个在线网站sslforfree在线申请 使用方式：1certbot certonly --webroot -w /var/www/blog/public -d blog.linyqiang.com 注意这里-w 一定要深入到public, 因为我blog放的是整个Node.js程序， 而静态文件是在public下 证书生成完毕后会在/etc/letsencrypt/live/blog.linyqiang.com/下面生成相应的文件。将nginx的ssl_certificate和ssl_certificate_key配置好， 然后nginx -s reload就行了 letsencrypt 会访问host/.well-known/acme-challenge 来检测该域名的有效性。如果出现访问错误，开一在Node.js程序中加入相应的路由 12cd /var/www/blogvi app.js 向路由中添加一下代码即可123456app.get('/.well-known/acme-challenge/:ids',function(req,res,next)&#123; require('fs').readFile(__dirname + '/public/.well-known/acme-challenge/'+req.params.ids,function(err,data)&#123; err&amp;&amp;console.log(err); res.send(data); &#125;);&#125;); 最后1pm2 restart app.js 然后https://blog.linyqiang.com 就成功上线啦！蛤蛤蛤蛤","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"再谈层叠上下文（stacking context）","date":"2017-10-15T04:04:07.000Z","path":"2017/10/15/再谈层叠上下文（stacking-context）/","text":"最开始由于对z-index和层叠上下文不理解，导致在项目中使用某些属性时出现了问题。现在来总结一下z-index和层叠上下文的一些东西 层叠上下文层叠上下文是一个三维概念。想象一下HTML元素是在屏幕上一层一层铺起来的，最上面的一层会被优先看到，下面的层会被上面的挡住 生成层叠上下文的条件： 根元素 position: relative 或者absolute，并且z-index不为auto position: fixed 或者sticky display 为flex的子元素，并且z-index不为auto opacity &lt; 1 mix-blend-mode 不为normal transform、filter、perspective、clip-path或mask不为none isolation: isolate -webkit-overflow-scrolling: touch … 层叠上下文是可包含的，独立的。每个层叠上下文与其相邻的层叠上下文互不干扰，每个层叠上下文可以包含层叠上下文。 层叠顺序层叠上下文的概念还是有点空洞，大部分时候只要记住层叠上下文的排列顺序就行了 根元素的背景和边框 普通流(normal flow)的后代元素按照他们在HTML中出现的先后顺序进行层叠 浮动块元素 常规流的后代行内元素 后代已定位元素按照他们在HTML中出现顺序进行层叠 比如说下面一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; width: 500px; margin: 0 auto; color: #fff; &#125; #box1 &#123; float: left; width: 200px; height: 200px; background-color: rgba(255, 0, 0, .8); &#125; #box2 &#123; width: 300px; height: 200px; background-color: rgba(0, 255, 0, .8); &#125; #box3 &#123; width: 200px; height: 200px; background-color: rgba(0, 0, 255, .8); margin-top: -100px; &#125; #box4 &#123; top: -50px; position: relative; width: 200px; height: 200px; background-color: rgba(0, 255, 255, .8); &#125; #box5 &#123; top: 350px; position: absolute; width: 200px; height: 200px; background-color: rgba(255, 0, 255, .8); &#125; .inlineBox1 &#123; margin-top: 20px; color: #fff; display: inline-block; /*width: 300px;*/ background-color: rgba(0, 0, 0, 1); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box1\"&gt;float #box1&lt;/div&gt; &lt;div id=\"box2\" class=\"normal\"&gt; normal flow1 #box2 &lt;/div&gt; &lt;div class=\"inlineBox1\"&gt;inline-block&lt;/div&gt; &lt;div id=\"box3\" class=\"normal\"&gt;normal flow2 #box3&lt;/div&gt; &lt;div id=\"box4\"&gt;position relative #box4&lt;/div&gt; &lt;div id=\"box5\"&gt;position absolute #box5&lt;/div&gt; &lt;div class=\"inlineBox2\"&gt;inline-block&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到float 元素#box1的确覆盖了普通流的#box2和#box3（第3个原则） 普通流的#box3 覆盖了普通流的#box2（第2个原则） position: relative的#box4 覆盖了normal flow 的#box3（第5个原则） position: absolute的#box5覆盖了#box4（第5个原则） inlineBox1 在#box3 之上 （第4个原则） z-index上面的顺序没有说明z-index 对层叠顺序的影响。如果已定位元素为z-index:auto，那么上面的顺序是完全ok的。如果设置了z-index，那么表现又会不一样。 具体为： 根元素的背景和边框 z-index: - 普通流(normal flow)的后代元素按照他们在HTML中出现的先后顺序进行层叠 浮动块元素 常规流的后代行内元素 z-index: auto z-index: + 现在我们给#box4 和 #box5添加z-index12345678910111213141516#box4 &#123; top: -50px; position: relative; width: 200px; height: 200px; background-color: rgba(0, 255, 255, .8); z-index: 1&#125;#box5 &#123; top: 350px; position: absolute; width: 200px; height: 200px; background-color: rgba(255, 0, 255, .8); z-index: -1;&#125; 再来看看效果： 没错，#box5 成功的跑到了#box4的下面；注意#box5的底部还漏出了‘inline-block’字样，这个是原本就放在#box5下面的inlineBox2。第一个例子没有显现出来，现在显示出来了。 现在看另外一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; width: 500px; margin: 0 auto; color: #fff; &#125; #box4 &#123; position: relative; width: 200px; height: 200px; background-color: rgba(0, 255, 255, .8); z-index: 1 &#125; #box5 &#123; margin-top: -100px; position: absolute; width: 200px; height: 200px; background-color: rgba(255, 0, 255, .8); z-index: -1; &#125; #box5-1 &#123; margin-top: 10px; position: absolute; width: 100px; height: 100px; background-color: rgba(255, 0 , 0, .8); z-index: 9999; &#125; #box5-2 &#123; position: absolute; width: 100px; height: 100px; background-color: rgba(0, 0, 255, 0.8); z-index: -1; margin-left: 80px;; margin-top: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box4\"&gt;position relative #box4 z-index: 1&lt;/div&gt; &lt;div id=\"box5\"&gt; position absolute #box5 z-index: -1 &lt;div id=\"box5-1\"&gt;#box5-1 z-index: 9999&lt;/div&gt; &lt;div id=\"box5-2\"&gt;#box5-2 z-index: -1&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果是这样的： 可以看到z-index: 9999 的#box-5-1并没有出现在所有元素的最上方，而是被#box4遮住了。 之所以会出现这种情况，是由于z-index只对当前层叠上下文有影响。 #box5设置了z-index: -1 过后就生成了层叠上下文，所以该层叠上下文包含的子元素的层叠顺序是基于该层叠上下文进行的。 层叠层次应该是这样： root element box4 box5 box5-1 box5-2 其他属性对层叠顺序的影响一旦普通元素具有了层叠上下文，其层叠顺序就会变高。 一旦某个元素具备产生层叠上下文的条件(比如：opacity: 0.8)，那么层叠的顺序会发生变换。 具体又分为两种条件： 不依赖z-index： 层叠顺序相当于z-index: auto 依赖z-index: 层叠顺序由z-index决定 来看一看opacity &lt; 1时候的表现： 12&lt;div id=\"box1\"&gt;#box1 normal flow&lt;/div&gt;&lt;div id=\"box2\"&gt;#box2 normal flow&lt;/div&gt; 123456789101112#box1 &#123; width: 200px; height: 200px; background-color: rgba(0, 255, 255, .8); opacity: 0.8;&#125;#box2 &#123; margin-top: -100px; width: 200px; height: 200px; background-color: rgba(255, 0, 255, .8);&#125; 没错！box1 在box2上面。如果不加opacity:0.8，normal flow按照规则应该是会遮挡box1，然而现在box1却在box2上面。 现在给#box2加上position:relative 1234567#box2 &#123; margin-top: -100px; width: 200px; height: 200px; background-color: rgba(255, 0, 255, .8); position: relative;&#125; ？？？box2又跑到上面去了？因为position: relative 并没有指定z-index，所以默认的层叠顺序的优先级就是z-index: auto。 不依赖z-index： 层叠顺序相当于z-index: auto 而opacity 不依赖z-index， 所以层叠顺序的优先级也和z-index: auto一样。同时，由于box2在HTML文档中位于box1的下方，因此box2遮挡了box1 由此看出记住层叠顺序相当重要哦！ 我感觉脑子有点乱～～～","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"transform和position fixed的恩怨","date":"2017-10-13T03:47:16.000Z","path":"2017/10/13/transform和position-fixed的恩怨/","text":"定位与z-index说起position这个东西，就不得不说z-index 属性， 说起z-index就不得不说层叠上下文 嗯……好复杂 参考 http://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/ https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index https://www.w3.org/TR/CSS21/zindex.html transform 对position fixed的影响使用transform 属性值不为’none’的元素会生成层叠上下文， 而z-index 对层叠水平的影响只有在当前层叠上下文元素中才有意义。因此什么position: fixed; z-index:9999 这种操作直接就跪了(ㄒoㄒ) transform 还会在某些chrome 版本或360浏览器中使position: fixed absolute化，也就是说position: fixed; right: 0 这种操作和 postition: absolute; right: 0; 一个样子 所以这两个东西属性怕是最好不要一起用，会很头痛","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"vue-router按需加载","date":"2017-10-13T03:36:15.000Z","path":"2017/10/13/vue-router按需加载/","text":"参考 https://router.vuejs.org/zh-cn/advanced/lazy-loading.html 其实很简单， 就是把路由index.js的组件引入改一下就行了 12345import Foo from '@/components/foo'======&gt;const Foo = import('@/components/foo') 虽然这样路由可以按需加载， 并且可以在需要跳转路由的时候再下载相应的路由有关的js文件了 理论上讲这样是可以提高首页的加载速度的， 因为毕竟请求的js文件少了嘛。 不过，如果网速不好，相应的js 下载过久的话，再跳转路由的时候会迟迟没有反应，体验也不见得会更好 怎么取舍就看需求了","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"使用JS动态获取背景颜色","date":"2017-09-21T05:45:26.000Z","path":"2017/09/21/使用JS动态获取背景颜色/","text":"在写vue-music的时候，希望把song-list组件做成向qq音乐那样，背景颜色根据歌单封面变化 就像这样： 使用canvas 的getImageData可以获取到图片的数据，包括rgba 但是canvas 存在跨域问题。因此服务器端需要设置响应头,并且客户端设置image.crossOrigin = &#39;anonymous&#39; 实现方式如下：1234567891011121314151617181920const HOST = '...';export function getImageColor (src) &#123; var canvas = document.createElement('canvas') var context = canvas.getContext('2d') var image = new Image() image.crossOrigin = 'anonymous' image.src = `$&#123;HOST&#125;/QQMusicAvatar?src=` + src var promise = new Promise((resolve, reject) =&gt; &#123; image.onload = function () &#123; var imgWidth = this.width var imgHeight = this.height canvas.width = imgWidth canvas.height = imgHeight context.drawImage(this, 0, 0, imgWidth, imgHeight) var imgData = context.getImageData(1, 1, 1, 1) resolve(imgData) &#125; &#125;) return promise&#125; 123456789101112131415161718192021// 接下来就可以在song-list 组件中调用getImageColor了// 比如说export default &#123; ... created () &#123; this._getImageColor(); &#125; methods: &#123; _getImageColor () &#123; getImageColor(this.focus.avatar) .then((imgData) =&gt; &#123; this.bgColor = `rgb($&#123;imgData.data[0]&#125;,$&#123;imgData.data[1]&#125;,$&#123;imgData.data[2]&#125;)` this.loadingComplete = true if (imgData.data[0] &gt; 100 &amp;&amp; imgData.data[1] &gt; 100 &amp;&amp; imgData.data[2] &gt; 100) &#123; this.isDark = false &#125; &#125;) &#125;, &#125; ...&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"vue-music 兼容性调整","date":"2017-09-21T04:49:38.000Z","path":"2017/09/21/vue-music-兼容性调整/","text":"前段时间学习vue的时候做了一个music webapp；对遇到的兼容性问题做一个总结 特性/兼容性 UC QQ Chrome WebView QQ内建 微信内建 filter:blur() 不支持 支持，但是卡顿 √ √ √ √ &lt;input type=&#39;range&#39;/&gt;自定义样式 不支持 支持 √ √ √ √ animation 不支持reverse，keyframe需要@-webkit前缀 √，keyframe需要@-webkit前缀 √ √ √ √ flex 只支持box-flex的老式写法 只支持box-flex的老式写法 √ √ √ √ 解决方案filter由于uc 和qq兼容性问题, 采用filter.blur() 实现播放器背景的模糊效果会出问题, 采用opacity代替。 input range检测浏览器类型，如果是uc 和 qq 或者firefox，讲input range 设置为display: none;，使用一个div 模拟input range；123456789101112131415161718192021222324&lt;!--进度条--&gt; &lt;div class=\"player-progress\"&gt; &lt;div style=\"flex: 2; box-flex: 2\"&gt;&#123;&#123;currentTimeFormatted&#125;&#125;&lt;/div&gt; &lt;div :style=\"&#123; flex: 10, display: BrowserType !== 'OK' ? 'none' : '' &#125;\"&gt; &lt;input type=\"range\" max=\"100\" v-model=\"progressValue\" class=\"progress\" :style=\"&#123; background: `linear-gradient(to right, currentColor $&#123;progressValue&#125;%, #fff $&#123;progressValue&#125;%, #fff)`, width: '100%' // uc 不支持input range &#125;\" &gt; &lt;/div&gt; &lt;div class=\"progress\" :style=\"&#123; display: BrowserType !== 'OK' ? '' : 'none', background: `linear-gradient(to right, currentColor $&#123;progressValue&#125;%, #fff $&#123;progressValue&#125;%, #fff)`, height: '1px', 'box-flex': 10 // uc 和 qq只支持box-flex的老式写法 &#125;\" &gt;&lt;/div&gt; &lt;div style=\"flex: 2; box-flex: 2\"&gt;&#123;&#123;intervalFormatted&#125;&#125;&lt;/div&gt; &lt;/div&gt; animation加上@-webkit 和 @-moz的前缀 flexflex 在uc 和qq 效果一般， 采用-webkit-box 效果好一些 判断浏览器类型1234567891011var a = navigator.userAgent// alert(a)if (a.match('UCBrowser')) &#123; window.sessionStorage.setItem('BrowserType', 'UCBrowser')&#125; else if (a.match('Firefox')) &#123; window.sessionStorage.setItem('BrowserType', 'Firefox')&#125; else if (a.match('QQBrowser')) &#123; window.sessionStorage.setItem('BrowserType', 'QQBrowser')&#125; else &#123; window.sessionStorage.setItem('BrowserType', 'OK')&#125; 移动端meta123456789101112131415161718192021222324252627282930313233refer to ：https://www.zhihu.com/question/19819577&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt;&lt;meta name=\"format-detection\"content=\"telephone=no, email=no\" /&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\" /&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt;&lt;!-- 删除苹果默认的工具栏和菜单栏 --&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;meta name=\"format-detection\" content=\"telphone=no, email=no\" /&gt;&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=\"renderer\" content=\"webkit\"&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=\"HandheldFriendly\" content=\"true\"&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=\"MobileOptimized\" content=\"320\"&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=\"screen-orientation\" content=\"portrait\"&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=\"x5-orientation\" content=\"portrait\"&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=\"full-screen\" content=\"yes\"&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=\"x5-fullscreen\" content=\"true\"&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=\"browsermode\" content=\"application\"&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=\"x5-page-mode\" content=\"app\"&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"socket.io 的使用","date":"2017-09-21T03:11:14.000Z","path":"2017/09/21/socket-io-的使用/","text":"首先配置好服务器123456789101112131415161718192021222324252627...... //前面省略...var server = app.listen(app.get('port'), function() &#123; console.log('node 正在运行，端口:'+app.get('port'));&#125;);var io = require('socket.io')(server, &#123; pingTimeout: 5000, pingInterval: 10000&#125;)io.on('connection', function(socket) &#123; console.log(socket.id) socket.on('disconnect', () =&gt; &#123; for(var i in oSocketIDs) &#123; if(oSocketIDs[i] === socket.id) &#123; delete(oSocketIDs[i]); &#125; &#125; delete(oSockets[socket.id]) &#125;) socket.on('chat message',(msg, fn) =&gt; &#123; io.emit('chat message', msg); fn('success') &#125;)&#125;) 然后客户端需要配置socket1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;ul id=\"messages\"&gt;&lt;/ul&gt; &lt;form action=\"\"&gt; &lt;input id=\"m\" autocomplete=\"off\" /&gt;&lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"https://code.jquery.com/jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;!-- 如果socket.io.js 和服务器不在一个域下面，则需要指定详细地址 --&gt; &lt;!-- &lt;script src='http://localhost:8888/socket.io/socket.io.js'&gt;&lt;/script&gt; --&gt; &lt;script&gt; var socket = io(); // 如果socket.io.js 和服务器不在一个域下面，则需要指定详细地址 // var socket = io('http://localhost:8888') $('form').submit(function(event) &#123; event.preventDefault(); socket.emit('chat message', $('#m').val()); return false; &#125;); socket.on('chat message', function(msg) &#123; $('#messages').append($('&lt;li&gt;').text(msg)); &#125;) $.ajax(&#123; url: '/test', type: 'get', data: &#123;param1: 'value1'&#125; &#125;) .done(function() &#123; console.log(\"success\"); &#125;) .fail(function() &#123; console.log(\"error\"); &#125;) .always(function() &#123; console.log(\"complete\"); &#125;); &lt;/script&gt;&lt;/body&gt; 客户端手动断开socket, 使用socket.close(); 手动重连socket.open(); socket监听事件,使用socket.on(); 服务端广播消息，io.emit:广播全部包括自己， socket.broadcast.emit: 广播全部不包括自己 socket.io 实现点对点发送消息实现方式：在io.on(‘connection’)的时候，所有的socket按照某种关键字保存起来, 比如一个对象oSockets。做{username: socket} 的对应关系。然后在服务器端监听到某个私有消息事件的时候，根据客户端指定的username，选择oSockets[username].emit(…)就行了123456789101112131415161718192021222324252627282930313233343536373839// 完整代码// 服务端var oSocketIDs = &#123;&#125;;var oSockets = &#123;&#125;;io.on('connection', function(socket) &#123; socket.on('create user', (username) =&gt; &#123; console.log(username) oSockets[username] = socket; oSocketIDs[username] = socket.id; socket.emit('find user', oSocketIDs); &#125;) console.log(socket.id) socket.on('disconnect', () =&gt; &#123; // 断开的时候删除oSocket的相应内容 for(var i in oSocketIDs) &#123; if(oSocketIDs[i] === socket.id) &#123; delete(oSocketIDs[i]); delete(oSockets[i]) &#125; &#125; &#125;) socket.on('private message', (from, to, data, fn) =&gt; &#123; oSockets[to].emit('private msg', data) // to 就代表要发送的某个用户 &#125;) socket.on('private filedata', (from, to ,data, fn) =&gt; &#123; if(!to) &#123; fn('error'); return; &#125; oSockets[to].emit('receive private file', data) fn('success') &#125;)&#125;)// 客户端window.socket.emit('private message', from , to, data,(ack) =&gt; &#123; ack === 'success' &amp;&amp; message.success('私信成功');&#125;);","tags":[{"name":"nodeJS","slug":"nodeJS","permalink":"http://yoursite.com/tags/nodeJS/"},{"name":"socket.io","slug":"socket-io","permalink":"http://yoursite.com/tags/socket-io/"},{"name":"websocket","slug":"websocket","permalink":"http://yoursite.com/tags/websocket/"}]},{"title":"一份完整的express4后台配置","date":"2017-09-21T03:01:28.000Z","path":"2017/09/21/一份完整的express4后台配置/","text":"备份一个express4 的后台配置，省的每次都要去重写一遍12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var express = require('express');var logger = require('morgan');var bodyParser = require('body-parser');var methodOverride = require('method-override');var errorHandler = require('errorhandler');var session = require('express-session');var cookieParser = require('cookie-parser');var app = express();app.set('port', 8888);app.use(logger('dev'));app.use(methodOverride());app.use(cookieParser());app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123;extended: true&#125;));app.use(session(&#123; resave: false, saveUninitialized: false, secret: '12345', cookie: &#123; maxAge: 1000 * 60 * 60 * 24, // default session expiration is set to 24 hour &#125;, name: 'send', rolling: false&#125;))app.use('/', express.static(__dirname + '/public'));app.use(function(req, res, next) &#123; console.log('hostname:' + req.hostname) var allowOrigins = [ 'http://www.linyqiang.com', \"http://localhost:3000\", 'http://192.168.1.101:3000' ]; var origin = req.headers.origin; if (allowOrigins.indexOf(origin) &gt; -1 || /(\\b|.*\\.)linyqiang.com$/.test(origin) === true) &#123; res.setHeader('Access-Control-Allow-Origin', origin); &#125; else &#123; res.setHeader('Access-Control-Allow-Origin', '*'); &#125; res.header('Access-Control-Allow-Credentials', true); res.header('Access-Control-Allow-Methods', 'GET,PUT,DELET,POST'); res.header('Access-Control-Allow-Headers', 'Content-Type,x-access-token,Access-Control-Allow-Headers, Authorization, X-Requested-With'); next();&#125;)app.use(errorHandler());process.on('uncaughtException', function(err) &#123; console.log(err);&#125;)；var server = app.listen(app.get('port'), function() &#123; console.log('node 正在运行，端口:'+app.get('port'));&#125;);","tags":[{"name":"nodeJS","slug":"nodeJS","permalink":"http://yoursite.com/tags/nodeJS/"},{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"}]},{"title":"nodeJS 设置跨域响应头","date":"2017-09-21T02:50:39.000Z","path":"2017/09/21/nodeJS-设置跨域响应头/","text":"12345678910111213141516171819app.use(function(req, res, next) &#123; console.log('hostname:' + req.hostname) var allowOrigins = [ 'http://www.linyqiang.com', \"http://localhost:3000\", 'http://192.168.1.101:3000' ]; var origin = req.headers.origin; if (allowOrigins.indexOf(origin) &gt; -1 || /(\\b|.*\\.)linyqiang.com$/.test(origin) === true) &#123; // 如果req.headers.origin 在 allowOrigin 里面，则指定origin可以跨域 res.setHeader('Access-Control-Allow-Origin', origin); &#125; else &#123; res.setHeader('Access-Control-Allow-Origin', '*'); &#125; res.header('Access-Control-Allow-Credentials', true); res.header('Access-Control-Allow-Methods', 'GET,PUT,DELET,POST'); res.header('Access-Control-Allow-Headers', 'Content-Type,x-access-token,Access-Control-Allow-Headers, Authorization, X-Requested-With'); next();&#125;) 分开指定res.setHeader(&#39;Access-Control-Allow-Origin&#39;, origin); 和res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);是因为有部分origin我希望能够使用withCredentials: true的方式发送cookie等信息。 如果简简单单的设置’ * ‘ 的话，客户端 1234fetch(url, &#123; withCredentials: true, // 无效，chrome会拦截 mode: 'cors'&#125;) 并且使用这种方式， 也会避免cookie 和session 跨域问题","tags":[{"name":"nodeJS","slug":"nodeJS","permalink":"http://yoursite.com/tags/nodeJS/"},{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"}]},{"title":"nodeJS 文件上传与下载","date":"2017-09-21T02:07:41.000Z","path":"2017/09/21/nodeJS-文件上传与下载/","text":"nodeJS 文件上传express 下使用body-parser是无法解析multipart/form-data的内容的，如果客户端发来文件内容，使用body-parser中间件是看不到文件的 此时需要引入multer模块，npm install multer -S123456789101112131415var bodyParser = require('body-parser');var upload = require('multer')(&#123; dest: 'uploads/' //指定文件上传后存放的位置&#125;)var app = require('express')();app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123;extended: true&#125;));app.listen('8888', function() &#123; console.log('.....')&#125;);app.post('/uploads',upload.any(), function(req, res) &#123; console.log(req.fields); console.log(req.files); // 此时可以在req.files 已上传内容的信息了 console.log(req.body);&#125;) 客户端使用FormData上传file Object12345678910111213141516171819&lt;form id=\"up\" name=\"up\" enctype=\"multipart/form-data\" method=\"POST\"&gt; &lt;input type=\"file\" name=\"file\" id=\"file\"/&gt; &lt;input type=\"submit\" id=\"submit\" /&gt;&lt;/form&gt;&lt;script&gt; var form = document.getElementById('up'); form.addEventListener('submit', function(e) &#123; e.preventDefault(); var data = new FormData(form); console.log(data); var en = data.entries(); console.log(en); for(var pair of en) &#123; console.log(pair); &#125; xhr.open('post','http://localhost:8888/upload',true); xhr.send(data); &#125;)&lt;/script&gt; nodeJS文件下载nodejs 实现下载的方式很多，最简单的一个就是静态化内容。1app.use('/download', express.static(__dirname + '/download')); 也可以采用sendFile的方式发送内容12345678app.get('/download:filename', (req, res) =&gt; &#123; var path = __dirname + '/download/' + req.params.filename; res.sendFile(path, function (err) &#123; if(!err) &#123; console.log('发送成功') &#125; &#125;)&#125;) 还可以采用Stream 发送文件123456789101112131415161718192021app.get('/download:filename', (req, res, next) &#123; let stat = fs.statSync(__dirname +'/uploads/' + req.params.filename); res.set(&#123; 'Content-Type': 'application/octet-stream', 'Content-Disposition': 'attachment', 'Content-Length': stat.size &#125;) let rd = fs.createReadStream(__dirname +'/uploads/' + result.filename, &#123; highWaterMark: 5000000 &#125;).pipe(res); rd.on('end', () =&gt; &#123; console.log('文件发送完毕'); try &#123; fs.unlink(__dirname +'/uploads/' + result.filename,(err)=&gt;&#123;!err &amp;&amp; console.log('文件已被成功下载，已删除文件')&#125;); result.remove(); &#125; catch (e) &#123; console.log(e); res.send(404); &#125; &#125;)&#125;) 最后还有一个简单的方式123456app.get('/download:filename', (req, res) =&gt; &#123; var path = __dirname + '/download/' + req.params.filename; res.download(path,(err) =&gt; &#123; ... &#125;)&#125;) 关于multer 上传文件后重命名为了防止文件重复，文件上传后是一个没有后缀名的，并且是一串字符串命名。使用diskStorage可以更改文件名12345678910var storage = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, '/uploads') &#125;, filename: function (req, file, cb) &#123; cb(null, file.fieldname + '-' + Date.now()) &#125;&#125;)var upload = multer(&#123; storage: storage &#125;)","tags":[{"name":"nodeJS","slug":"nodeJS","permalink":"http://yoursite.com/tags/nodeJS/"},{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"}]},{"title":"vue 中使用iScroll","date":"2017-09-09T16:06:49.000Z","path":"2017/09/10/vue-中使用iScroll/","text":"iScroll 是一个js 多平台滚动库，https://github.com/cubiq/iscroll 这几天用下来发现这个库确实强大，github的star数也已经到达10000多。在vue中使用iScroll 和平常使用大同小异，核心思路都一样。 使用时需要注意几个问题： iScroll 需要在DOM加载完毕过后在进行初始化 DOM 更新过后要执行refresh 如果需要监听scroll事件，需要使用iscroll-probe.js版本 iScroll 只会对第一个子节点实现滚动， 其余的子节点会自动忽略 iScroll 初始化指定的节点最好有position:relative; height: 100% 初始化指定的节点可以加上transform: translate3d(0,0,0)，以此开启硬件加速 vue 组件中初始化iScroll一定要在mounted钩子函数中，并且使用this.$nextTick()回调，也可以用setTimeout延迟执iScroll的初始化 可以自己通过iScroll实现一个vue组件，可以命名为Scroll；在Scroll 的 template中使用slot插槽， 可以很方便的自行决定Scroll 下面的DOM结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;template&gt; &lt;!-- iScroll初始化指定的div --&gt; &lt;div ref=\"wrapper\" class=\"scroll-wrapper\" style=\"position:relative; -webkit-transform:translate3d(0,0,0);overflow: hidden; height: 100%\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; // 主要的数据 ，这里是属性中的data，这个数据主要来自于父组件 data: &#123; type: Array, default: function () &#123; return null &#125; &#125;, // 设置一个refreshTrigger 数据， 只要这个数据改变就执行refresh refreshTrigger: &#123; type: [String, Array, Number], default: '' &#125;, // 是否监听Scroll ，如果true， 则iscroll 使用probeType: 3 来进行初始化 // 关于probeType： https://github.com/cubiq/iscroll#optionsprobetype listenScroll: &#123; type: Boolean, default: false &#125; &#125;, // 这个是vue组件中的data，和属性中的那个data不是一个东西 data () &#123; return &#123; scroll: null, timer: 0, timer2: 0 &#125; &#125;, methods: &#123; scrollTo () &#123; this.scroll &amp;&amp; this.scroll.scrollTo.apply(this.scroll, arguments) &#125;, scrollToElement () &#123; this.scroll &amp;&amp; this.scroll.scrollToElement.apply(this.scroll, arguments) &#125;, refresh () &#123; this.scroll &amp;&amp; this.scroll.refresh() &#125; &#125;, mounted () &#123; // 这里也可以使用this.$nextTick(() =&gt; &#123; this.scroll ... &#125;) this.timer = setTimeout(() =&gt; &#123; /* eslint-disable no-new */ this.scroll = new IScroll(this.$refs.wrapper, &#123; click: true, // 是否监听Scroll ，如果true， 则iscroll 使用probeType: 3 来进行初始化； probeType: this.listenScroll ? 3 : 1, preventDefault: true, HWCompositing: true, disablePointer: true, bounce: true, elastic: true &#125;) &#125;, 20) &#125;, watch: &#123; data (value) &#123; // 必须使用setTimeout 由于refresh 也是异步的 this.timer2 = setTimeout(() =&gt; &#123; this.scroll &amp;&amp; this.scroll.refresh() &#125;, 20) &#125;, refreshTrigger () &#123; this.refresh() &#125; &#125;, destroyed () &#123; clearTimeout(this.timer) clearTimeout(this.timer2) &#125; &#125;&lt;/script&gt;&lt;style scoped lang=\"stylus\" rel=\"stylesheet/stylus\"&gt; /* solve Unable to preventDefault inside passive event listener due to target being treated as passive */ .scroll-wrapper touch-action: none;&lt;/style&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"JavaScript高级程序设计笔记","date":"2017-08-22T16:00:00.000Z","path":"2017/08/23/JavaScript高级程序设计笔记/","text":"第 3 章 基本概念typeof 的返回值有undefined, boolean, string, number, object, function 对未初始化的变量执行 typeof 操作符会返回 undefined 值,而对未声明的变量执行 typeof 操作符同样也会返回 undefined 值 Number.MIN_VALUE 中——在大多数浏览器中,这个值是 5e-324;能够表示的最大数值保存在Number.MAX_VALUE 中——在大多数浏览器中,这个值是 1.7976931348623157e+308 0 除以 0 才会返回 NaN,正数除以 0 返回 Infinity,负数除以 0 返回-Infinity 转型函数 Number() 可以用于任何数据类型,而另两个函数则专门用于把字符串转换成数值 Number() 函数的转换规则如下: 如果是 Boolean 值, true 和 false 将分别被转换为 1 和 0。 如果是数字值,只是简单的传入和返回。 如果是 null 值,返回 0。 如果是 undefined ,返回 NaN 。 如果是字符串,遵循下列规则: 如果字符串中只包含数字(包括前面带正号或负号的情况),则将其转换为十进制数值,即 “1”会变成 1, “123” 会变成 123,而 “011” 会变成 11(注意:前导的零被忽略了); 如果字符串中包含有效的浮点格式,如 “1.1” ,则将其转换为对应的浮点数值(同样,也会忽略前导零); 如果字符串中包含有效的十六进制格式,例如 “0xf” ,则将其转换为相同大小的十进制整数值; 如果字符串是空的(不包含任何字符),则将其转换为 0; 如果字符串中包含除上述格式之外的字符,则将其转换为 NaN 。 如果是对象,则调用对象的 valueOf() 方法,然后依照前面的规则转换返回的值。如果转换的结果是 NaN ,则调用对象的 toString() 方法,然后再次依照前面的规则转换返回的字符串值。 String() 函数遵循下列转换规则: 如果值有 toString() 方法,则调用该方法(没有参数)并返回相应的结果; 如果值是 null ,则返回 “null” ; 如果值是 undefined ,则返回 “undefined” arguments 的行为,还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步 ECMAScript 中的所有参数传递的都是值,不可能通过引用传递参数 第四章 变量、作用域和内存问题执行环境定义了变量或函数有权访问的其他数据,决定了它们各自的行为 每个函数都有自己的执行环境。当执行流进入一个函数时,函数的环境就会被推入一个环境栈中。而在函数执行之后,栈将其环境弹出,把控制权返回给之前的执行环境 当代码在一个环境中执行时,会创建变量对象的一个作用域链(scope chain)。作用域链的用途,是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端,始终都是当前执行的代码所在环境的 变量对象。如果这个环境是函数,则将其活动对象(activation object)作为变量对象。活动对。作用域链中象在最开始时只包含一个变量,即 arguments 对象(这个对象在全局环境中是不存在的)的下一个变量对象来自包含(外部)环境,而再下一个变量对象则来自下一个包含环境。这样,一直延续到全局执行环境;全局执行环境的变量对象始终都是作用域链中的最后一个对象。 第五章 引用类型引用类型包括 Object,Array,Date,RegExp,Function,基本包装类型(Boolean,Number,String),单体内置对象(Global,Math) 第六章 面向对象的程序设计对象内部属性 属性 用途 默认值 [[Configurable]] 表示能否通过 delete 删除属性从而重新定义属性,能否修改属性的特性,或者能否把属性修改为访问器属性 true [[Enumerable]] 表示能否通过 for-in 循环返回属性 true [[Writable]] 表示能否修改属性的值 true [[value]] 包含这个属性的数据值 undefined 一旦把属性定义为不可配置的,就不能再把它变回可配置了。此时,再调用 Object.defineProperty() 方法修改除 writable 之外的特性,都会导致错误 理解原型 对象的方法 方法 用途 参数 Object.defineProperty() 修改属性的默认特性 属性所在的对象、属性的名字和一个描述符对象 Object.defineProperties() 一次定义多个属性 要添加和修改其属性的对象、对象的属性与第一个对象中要添加或修改的属性一一对应 Object.getOwnPropertyDescriptor() 取得给定属性的描述符 属性所在的对象和要读取其描述符的属性名称 Object.getPrototypeOf 返回[[Prototype]]的值 某个对象 obj.hasOwnProperty 只在给定属性存在于对象实例中时,才会返回 true 对象的某个属性 Object.keys 返回一个包含所有可枚举属性的字符串数组 某个对象 Object.getOwnPropertyNames 返回所有实例属性组成的数组，无论是否可枚举 某个对象 Object.create 原型式继承的规范化方法 某个对象、[对象属性的配置对象] 创建对象的方式 ：工厂模式、构造函数模式、原形模式、组合使用构造函数模式、动态原型模式、寄生构造函数模式、稳妥构造函数模式 要创建 Person 的新实例,必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下4个步骤: 创建一个新对象; 将构造函数的作用域赋给新对象(因此 this 就指向了这个新对象) 执行构造函数中的代码(为这个新对象添加属性); 返回新对象。 模式 缺点 工厂模式 没有解决对象识别的问题 构造函数模式 每个方法都会在每个实例上重新创建一遍 原型模式 会共享引用类型值的属性 组合使用构造函数模式 √ 动态原型模式 √ 寄生构造函数模式 — 稳妥构造函数模式 — 工厂模式 123456789101112function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\");var person2 = createPerson(\"Greg\", 27, \"Doctor\"); 构造函数模式 12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\"); 原型模式 123456789101112function Person()&#123;&#125;Person.prototype.name = \"Nicholas\";Person.prototype.age = 29;Person.prototype.job = \"Software Engineer\";Person.prototype.sayName = function()&#123;alert(this.name);&#125;;var person1 = new Person();person1.sayName();//\"Nicholas\"var person2 = new Person(); 组合使用构造函数模式 1234567891011121314151617181920212223function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [\"Shelby\", \"Court\"];&#125;Person.prototype = &#123; constructor : Person, sayName : function()&#123; alert(this.name); &#125; &#125;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\");person1.friends.push(\"Van\");alert(person1.friends);//\"Shelby,Count,Van\"alert(person2.friends);//\"Shelby,Count\"alert(person1.friends === person2.friends);//falsealert(person1.sayName === person2.sayName);//true 动态原型模式 123456789101112131415function Person(name, age, job)&#123; //属性 this.name = name; this.age = age; this.job = job; //方法 if (typeof this.sayName != \"function\")&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125;&#125;var friend = new Person(\"Nicholas\", 29, \"Software Engineer\");friend.sayName(); 重写原型对象会切断现有原型与任何之前已经存在的对象实例之间的联系;它们引用的仍然是最初的原型 继承方式：原型链、借用构造函数模式、组合继承、原型式继承、寄生式继承、寄生组合式继承 继承方式 优缺点 原型链 引用类型值的原型属性会被所有实例共享 ，在创建子类型的实例时,不能向超类型的构造函数中传递参数 借用构造函数 函数无法复用 组合继承 √，但超类构造函数会被调用两次 原型式继承 — 寄生式继承 — 寄生组合式继承 √，解决了组合继承两次调用的问题 原型链继承 1234567891011121314151617181920function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue());//true 借用构造函数继承 1234567891011121314function SuperType()&#123; this.colors = [\"red\", \"blue\", \"green\"];&#125;function SubType()&#123;//继承了 SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(\"black\");alert(instance1.colors);//\"red,blue,green,black\"var instance2 = new SubType();alert(instance2.colors);//\"red,blue,green\" 组合继承 12345678910111213141516171819202122232425262728293031323334function SuperType(name)&#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; //继承属性 SuperType.call(this, name); this.age = age;&#125;//继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;var instance1 = new SubType(\"Nicholas\", 29);instance1.colors.push(\"black\");alert(instance1.colors);//\"red,blue,green,black\"instance1.sayName();//\"Nicholas\";instance1.sayAge();//29var instance2 = new SubType(\"Greg\", 27);alert(instance2.colors);//\"red,blue,green\"instance2.sayName();//\"Greg\";instance2.sayAge();//27 原型式继承 12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 寄生式继承 1234567function createAnother(original)&#123; var clone = object(original); clone.sayHi = function()&#123; alert(\"hi\"); &#125;; return clone;&#125; 寄生组合式继承 1234567891011121314151617181920function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;&#125;function SuperType(name)&#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;; 第七章 函数表达式闭包 概念： 闭包是指有权访问另一个函数作用域中的变量的函数 作用域链本质上是一个指向变量对象的指针列表,它只引用但不实际包含变量对象 闭包形成原因： 函数在执行完毕后,其活动对象也不会被销毁,因为匿名函数的作用域链仍然在引用这个活动对象 使用立即执行函数这种做法可以减少闭包占用的内存问题,因为没有指向匿名函数的引用。只要函数执行完毕,就可以立即销毁其作用域链了 第八章 BOMsetTimeout 和 setInterval JavaScript 是一个单线程序的解释器,因此一定时间内只能执行一段代码。为了控制要执行的代码,就有一个 JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。 setTimeout() 的第二个参数告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的,那么添加的代码会立即执行;如果队列不是空的,那么它就要等前面的代码执行完了以后再执行。 超时调用的代码都是在全局作用域中执行的,因此函数中 this 的值在非严格模式下指向 window 对象,在严格模式下是 undefined 般认为,使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下,很少使用真正的间歇调用,原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像前面示例中那样使用超时调用,则完全可以避免这一点。所以,最好不要使用间歇调用 location 可以使用document.location 和 window.loaction访问 它提供了与当前窗口中加载的文档有关的信息,还提供了一些导航功能 属性名 例子 说明 hash ‘#content’ 返回URL中的hash(#号后跟零或多个字符),如果URL中不包含散列,则返回空字符串 host “www.wrox.com:80” 返回服务器名称和端口号(如果有) hostname “www.wrox.com” 返回不带端口号的服务器名称 href http:/www.wrox.com” 返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值 pathname “/WileyCDA/“ 返回URL中的目录和(或)文件名 port “8080” 返回URL中指定的端口号。如果URL中不包含端口号,则这个属性返回空字符串 protocol “http:” 返回页面使用的协议。通常是http:或https: search “?q=javascript” 返回URL的查询字符串。这个字符串以问号开头 第22章 高级技巧作用域安全的构造函数1234567891011121314151617function Person(name, age, job)&#123; if (this instanceof Person)&#123; this.name = name; this.age = age; this.job = job; &#125; else &#123; return new Person(name, age, job); &#125;&#125;var person1 = Person(\"Nicholas\", 29, \"Software Engineer\");alert(window.name);//\"\"alert(person1.name);//\"Nicholas\"var person2 = new Person(\"Shelby\", 34, \"Ergonomist\");alert(person2.name);//\"Shelby\" 使用作用域安全的构造函数会使得call和apply 方法失效，解决办法是使用原型 123456789101112131415161718192021222324function Polygon(sides)&#123; if (this instanceof Polygon) &#123; this.sides = sides; this.getArea = function()&#123; return 0; &#125;; &#125; else &#123; return new Polygon(sides); &#125;&#125;function Rectangle(width, height)&#123; Polygon.call(this, 2); this.width = width; this.height = height; this.getArea = function()&#123; return this.width * this.height; &#125;;&#125;Rectangle.prototype = new Polygon();var rect = new Rectangle(5, 10);alert(rect.sides);//2 由于指定了Rectangele的prototype为Ploygon的实例，因此一个 Rectangle 实例也同时是一个 Polygon 实例。这样Polygon的 instance 检测就会通过 惰性载入函数123456789101112131415161718192021222324252627var createXHR = (function()&#123; if (typeof XMLHttpRequest != \"undefined\")&#123; return function()&#123; return new XMLHttpRequest(); &#125;; &#125; else if (typeof ActiveXObject != \"undefined\")&#123; return function()&#123; if (typeof arguments.callee.activeXString != \"string\")&#123; var versions = [\"MSXML2.XMLHttp.6.0\", \"MSXML2.XMLHttp.3.0\", \"MSXML2.XMLHttp\"], i, len; for (i=0,len=versions.length; i &lt; len; i++)&#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex)&#123; //skip &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125;; &#125; else &#123; return function()&#123; throw new Error(\"No XHR object available.\"); &#125;; &#125;&#125;)(); 惰性载入表示函数执行的分支仅会发生一次, 惰性载入表示函数执行的分支仅会发生一次","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"数组去重","date":"2017-08-21T15:18:27.000Z","path":"2017/08/21/优化的数组去重/","text":"传统数组去重123456789Array.prototype.unique = function() &#123; var a = [], l = this.length; for(var i=0; i&lt;l; i++) &#123; for(var j=i+1; j&lt;l; j++) if (this[i] === this[j]) j = ++i; a.push(this[i]); &#125; return a;&#125;; 优化数组去重方法,利用对象的键名不重复来筛选数组123456Array.prototype.unique = function() &#123; var o = &#123;&#125;, i, l = this.length, r = []; for(i=0; i&lt;l;i+=1) o[this[i]] = this[i]; for(i in o) r.push(o[i]); return r;&#125;; 还有一种比较简便的方法1234567function unique1(array)&#123; var n = []; for(var i = 0; i &lt; array.length; i++)&#123; if (n.indexOf(array[i]) == -1) n.push(array[i]); &#125; return n;&#125; 最后还有一个最简便的方法1var a = [new Set(someArray)] 后两种需要考虑兼容性, 但是比较简便,第二个方法的性能完胜第一个","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"react 个人小项目开发question","date":"2017-08-19T02:18:37.000Z","path":"2017/08/19/react-个人小项目开发question/","text":"React Component Lifecyclehttps://solome.js.org/web/react/2016/11/30/react-lifecycle.html React.createElement: type is invalid – expected a string or a class/function but got: undefinedresolution: 12345678910&lt;Menu.Item key='logout' className='register'&gt; &lt;Button type=\"primary\"&gt;&#123;this.state.username&#125;&lt;/Button&gt; &amp;nbsp;&amp;nbsp; &#123;/* &lt;Link target='_blank'&gt;&lt;Button type='dashed'&gt;个人中心&lt;/Button&gt;&lt;/Link&gt; */&#125; &lt;Button type=\"ghost\"&gt;退出&lt;/Button&gt;&lt;/MenuItem&gt;//error:&lt;Menu.Item key='register' className='register'&gt; &lt;Icon type=\"appstore\"/&gt;注册/登录&lt;/MenuItem&gt; to 123456789101112...const MenuItem = Menu.Item;&lt;MenuItem key='logout' className='register'&gt; &lt;Button type=\"primary\"&gt;&#123;this.state.username&#125;&lt;/Button&gt; &amp;nbsp;&amp;nbsp; &#123;/* &lt;Link target='_blank'&gt;&lt;Button type='dashed'&gt;个人中心&lt;/Button&gt;&lt;/Link&gt; */&#125; &lt;Button type=\"ghost\"&gt;退出&lt;/Button&gt;&lt;/MenuItem&gt;:&lt;MenuItem key='register' className='register'&gt; &lt;Icon type=\"appstore\"/&gt;注册/登录&lt;/MenuItem&gt; Warning: Failed context type: The context router is marked as required in Link, but its value is undefined.resolution: change /src/root.js12345678&lt;div&gt; &lt;MediaQuery query='(min-device-width:997px)'&gt; &lt;PCIndex /&gt; &lt;/MediaQuery&gt; &lt;MediaQuery query='(max-device-width:997px)'&gt; &lt;MobileIndex /&gt; &lt;/MediaQuery&gt;&lt;/div&gt; to 12345678910&lt;Router&gt; &lt;div&gt; &lt;MediaQuery query='(min-device-width:997px)'&gt; &lt;PCIndex /&gt; &lt;/MediaQuery&gt; &lt;MediaQuery query='(max-device-width:997px)'&gt; &lt;MobileIndex /&gt; &lt;/MediaQuery&gt; &lt;/div&gt;&lt;/Router&gt; how to modify themes of ant design via third-party or custom webpackConfigresolution: change webpack.config.js to1234567891011121314151617181920212223242526272829&#123; test: /\\.js?$/, exclude: /(node_modules)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['react','es2015'], // ant design babel-plugin-import plugins: [['import',&#123;'libraryName':'antd','style':true&#125;]] &#125; &#125;&#125;,&#123; test: /\\.less$/, include: path.resolve(__dirname, './node_modules'), use: [ 'style-loader', 'css-loader', &#123; loader: 'less-loader', options: &#123; // add less-loader option 'modifyVars' to change less var that defined in ant-design css modifyVars: &#123; \"primary-color\": '#1da57a' &#125; &#125; &#125; ]&#125; loading static sources (images) with webpackresolutions: add rules like this1234567891011&#123; test: /\\.(png|jpe?g|gif|svg)$/, exclude: /(node_modules)/, use: &#123; loader: 'url-loader', options: &#123; limit: 8192, name: 'img/[hash:5].[ext]' &#125; &#125;&#125; now can use require(...) or ‘import’ to load images by relative path in jsx; how to use css media query in css-moduleshttps://npm.taobao.org/package/postcss-modules-values cannot read videos of nullwhen map the this.state.videosresolution:add this.state={...} to constructor 1234567891011constructor() &#123;&#125;toconstructor() &#123; this.state= &#123; videos: ''; &#125;&#125; how to use Promise.all to fetch two urls simultaneouslyrefer to: https://segmentfault.com/q/1010000004101262/a-1020000004101642 how to use BMap with webpackresolution:add option externals to the end of webpack-config.js12345678module.exports = &#123; ... entry... output... externals: &#123; 'BMap': 'BMap' &#125;&#125; and then import BMap from &#39;BMap&#39; when you need; where to find svg picspixabay.com this.props.dispatch is not a functionwhen using react-redux to connect store and component;resolution: explicitly return it yourself in mapDispatchToProps implementation;12345const mapDispatchToProps = (dispatch,ownProps) =&gt; &#123; return &#123; \"dispatch\": dispatch, &#125;&#125; ant design Carousel component connot autoplay when using react-redux to connect component which has imported the Carouselresolution:dont use “connect” for Carousel contained components; ant design Tabs animated lag during switch tabpane via big datado not forget to call callback in the validator of Form.Item when you call this.props.form.validateFields or this.props.form.validateFieldsAndScroll with a Form.Item which contains a validator’s callback not called123456789101112131415&#123;getFieldDecorator('r_confirm',&#123; rules: [&#123; required: true, message: '请确认密码' &#125;, &#123; validator: (rule, value, callback) =&gt; &#123; if(value &amp;&amp; value!==this.props.form.getFieldValue('r_password')) &#123; callback('密码不一致') &#125; &#125; &#125;]&#125;)( &lt;Input type=\"password\" placeholder='请确认您的密码' /&gt;)&#125; is not equal to:12345678910111213141516&#123;getFieldDecorator('r_confirm',&#123; rules: [&#123; required: true, message: '请确认密码' &#125;, &#123; validator: (rule, value, callback) =&gt; &#123; if(value &amp;&amp; value!==this.props.form.getFieldValue('r_password')) &#123; callback('密码不一致') &#125; callback() &#125; &#125;]&#125;)( &lt;Input type=\"password\" placeholder='请确认您的密码' /&gt;)&#125; nodejs server router is in conflict with react-router BrowserRouterresolution:use HashRouter instead of BrowserRouter or manualy set histroyFallbackhttp://www.cnblogs.com/YZH-chengdu/p/6855237.html textarea height auto increment1234567891011121314151617181920212223(() =&gt; &#123; // textarea height auto increment var textarea = document.getElementById('textarea'); // hide scroll bar textarea.style.overflow = 'hidden'; var height = parseInt(window.getComputedStyle(textarea).height); var width = parseInt(window.getComputedStyle(textarea).width); var autoHeight = function() &#123; if(this.scrollHeight &lt;= height || this.value == '') &#123; this.style.height=height + 'px'; return; &#125; this.style.height = this.scrollHeight + 'px'; &#125; textarea.oninput = autoHeight; textarea.onpropertychange = function (event) &#123; if(event.propertyName.toLowerCase() == 'value') &#123; autoHeight(); console.log(this.value); &#125; &#125;&#125;)()","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"textarea 实现高度自动增长","date":"2017-08-19T01:50:30.000Z","path":"2017/08/19/textarea-实现高度自动增长/","text":"有时候希望textarea 能够自动调整高度来适应输入的内容 网上看到了很多解决方案，比如动态创建一个隐藏的div，当用户输入的时候将textarea的内容绑定到div，由于div的高度会自动撑开，因此可以动态检测div的高度，然后将div的高度复制给textarea。这个方法应该是兼容性较好而且比较稳健的办法，但实在太繁琐 还有一个解决办法就是动态将textarea的scrollHeight 复制给高度。我采用的是后者 1234567891011121314var textarea = document.getElementById('textarea'); // hide scroll bartextarea.style.overflow = 'hidden';var height = parseInt(window.getComputedStyle(textarea).height);var width = parseInt(window.getComputedStyle(textarea).width);var autoHeight = function() &#123; if(this.scrollHeight &lt;= height || this.value == '') &#123; this.style.height=height + 'px'; return; &#125; this.style.height = this.scrollHeight + 'px';&#125;textarea.oninput = autoHeight; 这个方法就是通过监听textarea的oninput 来实现，也可以监听keyup，keydown；但是如果使用keyup或者keydown来监听的话会存在一个问题，那就是如果textarea有复制或者剪切操作，keyup，keydown不会立即响应内容的变化，并且也不能响应鼠标右键粘贴。 最后再象征性地增加兼容123456textarea.onpropertychange = function (event) &#123; if(event.propertyName.toLowerCase() == 'value') &#123; autoHeight(); console.log(this.value); &#125;&#125; 然而悲伤的是这种方式并不适用移动端，移动端所有浏览器均测试无效 另外还有一个解决办法就是不使用textarea，而是使用普通div模拟textarea，因为div本身高度就自动增长，所有就不用担心其他问题了。实现方式就是给div设置属性contentEditable=true，这样div就变为可编辑的了。不过这种方式在某些firefox上面，div外层会出现虚框，从而使得div的本质暴露无疑。解决办法就是css配置outline:0 none","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"react-router V4 踩坑","date":"2017-08-01T02:59:12.000Z","path":"2017/08/01/react-router-V4-踩坑/","text":"The prop `history` is marked as required in `Router` …The prop `history` is marked as required in `Router`, but its value is `undefined`. in Router 解决办法:出现这个报错是因为我用npm 安装的是react-router v4，react-router v4不再使用&lt;Router history={hashHistory}&gt; 这种方式定义history 实现类型。而是直接通过组件如BrowserRouter,HashRouter等 123456789101112131415161718import &#123;Router, Route, hashHistory&#125; from 'react-router';&lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;Main&#125;&gt;&lt;/Route&gt;&lt;/Router&gt;===&gt;import &#123;BrowserRouter as Router, Route&#125; from 'react-router-dom';&lt;Router&gt; &lt;Route path=\"/\" component=&#123;Main&#125;&gt;&lt;/Route&gt;&lt;/Router&gt;或者&lt;HashRouter&gt; &lt;Route path=\"/\" component=&#123;Main&#125;&gt;&lt;/Route&gt;&lt;/HashRouter&gt; A ‘Router’ may have only one child elementreact-router v4 在 下面只能放一个层级，类似与react 中render 不能有两个平级div一样 解决办法：用div 或者Switch 包裹所有Route12345678&lt;Router&gt; &lt;div&gt; &lt;Route component=&#123;ComponentHeader&#125;&gt;&lt;/Route&gt; &lt;Switch&gt; &lt;Route component=&#123;ComponentFooter&#125; path='/footer/:id'&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt;&lt;/Router&gt; webpack 配置问题v4 中引入&lt;BrowserRouter&gt; 组件, 而BrowserRouter使用的是HTML5 的history api, 在使用webpack-dev-server时会遇到 GET http://localhost:8080/xxx/xxx 404 (Not Found) 解决办法：webpack.config.js中加入1234567devServer: &#123; apiHistoryFallback: true,&#125;output: &#123; ..., publicPath: '/',&#125; 然后将index.html中的bundle.js改为/bundle.js 1&lt;script src='bundle.js'&gt;&lt;/script&gt; ===&gt; &lt;script src='/bundle.js'&gt;&lt;/script&gt; 参考：https://stackoverflow.com/questions/43209666/react-router-v4-cannot-get-url questionhttps://segmentfault.com/q/1010000010432084?_ea=2287891 静态路由和动态路由https://reacttraining.com/react-router/web/guides/philosophy react-router 传参使用/xxx/:someparam 的形式书写Route 的path属性，如：1&lt;Route component=&#123;ComponentFooter&#125; path='/footer/:id'&gt;&lt;/Route&gt; 然后Link 的to属相加上参数即可，如： 1&lt;Link to='/footer/1234'&gt;Ant design demo 1&lt;/Link&gt; 最后在ComponentFooter中通过this.props.match.params访问，如： 123&lt;footer className=&#123;footerCss.miniFooter&#125;&gt; &lt;em&gt;id:&#123;this.props.match.params.id&#125;&lt;/em&gt;&lt;/footer&gt; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * js| * |root.js */import React from 'react';import ReactDOM from 'react-dom';import ComponentHeader from './components/header';// import ComponentFooter from './components/footer';var footerCss = require('../css/footer.css');import &#123;BrowserRouter as Router, Route, Switch, Link&#125; from 'react-router-dom';class App extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;Route component=&#123;ComponentHeader&#125;&gt;&lt;/Route&gt; &lt;Switch&gt; &lt;Route component=&#123;ComponentFooter&#125; path='/footer/:id'&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;class ComponentFooter extends React.Component &#123; constructor() &#123; super(); &#125; render() &#123; return ( &lt;footer className=&#123;footerCss.miniFooter&#125;&gt; &lt;em&gt;id:&#123;this.props.match.params.id&#125;&lt;/em&gt; &lt;h1&gt;&lt;Link to=&#123;`$&#123;this.props.match.url&#125;/cr`&#125;&gt;footer&lt;/Link&gt;&lt;/h1&gt; &lt;Route component=&#123;CopyRight&#125; path=&#123;`$&#123;this.props.match.url&#125;/cr`&#125;&gt;&lt;/Route&gt; &lt;/footer&gt; ) &#125;&#125;class CopyRight extends React.Component &#123; constructor() &#123; super(); &#125; render() &#123; return ( &lt;a&gt;copyright&lt;/a&gt; ) &#125;&#125;ReactDOM.render( &lt;App /&gt;,document.getElementById('root'))/** * js| * |components| * |header.js */import React from 'react';import &#123;Link&#125; from 'react-router-dom';var headerCss = require('../../css/header.css');export default class Header extends React.Component &#123; constructor() &#123; super(); &#125; render() &#123; console.log(headerCss); return ( &lt;header className=&#123;headerCss.bgheader&#125;&gt; &lt;h1&gt;&lt;Link to='/footer/1234'&gt;Ant design demo 1&lt;/Link&gt;&lt;/h1&gt; &lt;/header&gt; ) &#125;&#125;","tags":[]},{"title":"webpack css-modules 和global css 共存","date":"2017-07-30T09:29:14.000Z","path":"2017/07/30/webpack-css-modules-和global-css-共存/","text":"在使用ant design 时候遇到ant design css 和自定义的css 冲突的问题。./node_modules/ 中ant desing 的css 文件作为全局的css 和 自定义的css_modules 会发生冲突。解决办法是将/node_modules/中的css与自定义的css 分开处理。即对css_modules使用exclude:/node_modules/，对node_modules中的css使用include:path.resolve(__dirname,&#39;node_modules&#39;) 最开始定义的webpack.config.js 的处理方式：123456789101112131415161718192021222324252627282930313233343536373839404142var webpack = require('webpack');var path = require('path');module.exports = &#123; context: __dirname+'/src', entry: \"./js/index.js\", module: &#123; rules: [ &#123; test: /\\.js?$/, exclude: /(node_modules)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['react','es2015'], // ant design babel-plugin-import plugins: [['import',&#123;'libraryName':'antd','style':'css'&#125;]] &#125; &#125; &#125;, &#123; test: /\\.css$/, exclude: /(node_modules)/, use: [ &#123;loader:'style-loader'&#125;, &#123; loader: 'css-loader', options: &#123; modules: true, loacalIdentName: '[name]__[local]_[hash:base64:5]', sourceMap: true, importLoaders: 1 &#125; &#125; ] &#125;, ] &#125;, output: &#123; path: __dirname+'/src', filename: 'bundle.js' &#125;&#125; 报错： ERROR in ./node_modules/antd/lib/button/style/index.cssModule parse failed: /home/johnny/Project/react/demo3/node_modules/antd/lib/button/style/index.css Unexpected token (1:0)You may need an appropriate loader to handle this file type. 找到解决办法是，分别处理node_modules(ant design)中的css和css_modules：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var webpack = require('webpack');var path = require('path');module.exports = &#123; context: __dirname+'/src', entry: \"./js/index.js\", module: &#123; rules: [ &#123; test: /\\.js?$/, exclude: /(node_modules)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['react','es2015'], plugins: [['import',&#123;'libraryName':'antd','style':'css'&#125;]] &#125; &#125; &#125;, // css_modules 处理方式 &#123; test: /\\.css$/, exclude: /(node_modules)/, use: [ &#123;loader:'style-loader'&#125;, &#123; loader: 'css-loader', options: &#123; modules: true, loacalIdentName: '[name]__[local]_[hash:base64:5]', sourceMap: true, importLoaders: 1 &#125; &#125; ] &#125;, // ant design 处理方式 &#123; test: /\\.css$/, include: path.resolve(__dirname, 'node_modules'), use: [ &#123;loader:'style-loader'&#125;, &#123; loader:'css-loader', &#125; ] &#125;, ] &#125;, output: &#123; path: __dirname+'/src', filename: 'bundle.js' &#125;&#125;","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"react-native学习日记之ListView二","date":"2017-02-08T05:35:04.000Z","path":"2017/02/08/react学习日记之ListView二/","text":"用listView实现九宫格效果这次时照着es6的写法写的，es6和es5的写法有很多地方不一样123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, ListView, TouchableOpacity, Image&#125; from 'react-native';import Dimensions from 'Dimensions';const listData = [ &#123; src:'a', desc:'第一张' &#125;, &#123; src:'b', desc:'第二张' &#125;, &#123; src:'c', desc:'第三张' &#125;, &#123; src:'d', desc:'第四张' &#125;, &#123; src:'e', desc:'第五张' &#125;, &#123; src:'b', desc:'第二张' &#125;, &#123; src:'c', desc:'第三张' &#125;, &#123; src:'d', desc:'第四张' &#125;, &#123; src:'e', desc:'第五张' &#125;];// 获取屏幕宽高var &#123;width,height&#125; = Dimensions.get('window');var cols = 3; //3列var cellWidth = 100,cellHeight = 100;var vMargin = (width-cols*cellWidth)/(cols+1); //九宫格横向margin算法var hMargin = 20; //九宫格纵向marginexport default class ListViewjiugongge extends Component &#123; constructor(props) &#123; super(props); const ds = new ListView.DataSource(&#123;rowHasChanged:(r1,r2)=&gt;r1!==r2&#125;); this.state = &#123; dataSource: ds.cloneWithRows(listData) &#125; &#125; render() &#123; return ( &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this.renderRow&#125; // renderSeparator=&#123;(sectionID,rowID,adjacentRowHighlighted)=&gt;&#123; // console.log(sectionID,rowID,adjacentRowHighlighted); // return( // &lt;View key=&#123;`$&#123;sectionID&#125;-$&#123;rowID&#125;`&#125; // style=&#123;&#123;height:90,width:1,backgroundColor:adjacentRowHighlighted?'blue':'red'&#125;&#125; // &gt;&lt;/View&gt; // ) // &#125;&#125; contentContainerStyle=&#123;styles.listViewStyle&#125; /&gt; ); &#125; renderRow(owData,sectionID,rowID,highlightRow) &#123; return( &lt;TouchableOpacity activeOpacity=&#123;0.5&#125; onPress=&#123;()=&gt;&#123;highlightRow(sectionID,rowID)&#125;&#125;&gt; &lt;View style=&#123;styles.cellViewStyle&#125;&gt; &#123;/*图片src*/&#125; &lt;Image source=&#123;&#123;uri:owData.src&#125;&#125; style=&#123;&#123;width:100,height:100,borderRadius:50&#125;&#125;/&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; listViewStyle: &#123; flexDirection:'row', flexWrap:'wrap', alignItems:'flex-start' &#125;, cellViewStyle: &#123; marginLeft:vMargin, marginTop: hMargin &#125;, descStyle: &#123; // flexDirection:'row', // alignItems:'center' &#125;&#125;);AppRegistry.registerComponent('ListViewjiugongge', () =&gt; ListViewjiugongge);","tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"react-native学习日记之ListView","date":"2017-02-08T05:35:04.000Z","path":"2017/02/08/react学习日记之ListView/","text":"react-native ListView DOC ListView 基本用法1234567891011121314151617181920212223242526//es5 写法var ListViewDemo = React.createClass(&#123; getInitialState() &#123; // 设置初始值 // 1.1 设置数据源 var ds = new ListView.DataSource(&#123;rowHasChanged:(r1,r2)=&gt;r1!==r2&#125;); // 1.2 设置返回数据 return &#123; //listData 为一个数组格式 dataSource: ds.cloneWithRows(listData) &#125; &#125;, // 设置render函数 render() &#123; return ( &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this.renderListView&#125; //this.renderListView后不加括号表示默认接受所有参数（owData，sectionID...) /&gt; ); &#125;, renderListView(owData, sectionID, rowID, highlightRow) &#123; //renderRow 回调函数 &#125;&#125; 12345678910111213141516171819//es6 写法class MyComponent extends Component &#123; constructor() &#123; super(); const ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;); this.state = &#123; dataSource: ds.cloneWithRows(listData), &#125;; &#125; render() &#123; return ( &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this.renderListView&#125; /&gt; ); &#125;&#125; 完整demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * Sample React Native App * https://github.com/facebook/react-native * @flow */import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, ListView, Image, TouchableOpacity, Alert&#125; from 'react-native';var listData = [ &#123; src:'a', desc:'第一张' &#125;, &#123; src:'b', desc:'第二张' &#125;, &#123; src:'c', desc:'第三张' &#125;, &#123; src:'d', desc:'第四张' &#125;, &#123; src:'e', desc:'第五张' &#125;, &#123; src:'b', desc:'第二张' &#125;, &#123; src:'c', desc:'第三张' &#125;, &#123; src:'d', desc:'第四张' &#125;, &#123; src:'e', desc:'第五张' &#125;];var ListViewDemo = React.createClass(&#123; getInitialState() &#123; // 设置初始值 // 1.1 设置数据源 var ds = new ListView.DataSource(&#123;rowHasChanged:(r1,r2)=&gt;r1!==r2&#125;); // 1.2 设置返回数据 return &#123; dataSource: ds.cloneWithRows(listData) &#125; &#125;, // 设置render函数 render() &#123; return ( &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this.renderListView&#125; renderSeparator=&#123;(sectionID, rowID, adjacentRowHighlighted)=&gt;&#123; return ( &lt;View key=&#123;`$&#123;sectionID&#125;-$&#123;rowID&#125;`&#125; style=&#123;&#123;height:1,backgroundColor:adjacentRowHighlighted?'blue':'red'&#125;&#125; &gt;&lt;/View&gt; ); &#125;&#125; /&gt; ); &#125;, // renderRow的回调函数 renderListView(owData, sectionID, rowID, highlightRow) &#123; return ( &lt;TouchableOpacity activeOpacity=&#123;0.5&#125; onPress=&#123;()=&gt;highlightRow(sectionID,rowID)&#125;&gt; &lt;View style=&#123;styles.cellViewStyle&#125;&gt; &#123;/*左边的图片src*/&#125; &lt;Image source=&#123;&#123;uri:owData.src&#125;&#125; style=&#123;&#123;width:100,height:100,marginRight:15,borderRadius:50&#125;&#125;/&gt; &#123;/*右边的图片描述desc*/&#125; &lt;View style=&#123;styles.descStyle&#125;&gt; &lt;Text&gt; &#123;owData.desc&#125; &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ); &#125;&#125;)const styles = StyleSheet.create(&#123; cellViewStyle: &#123; // borderBottomWidth: 1, // borderBottomColor: '#eeeeee', flexDirection:'row', &#125;, descStyle: &#123; flexDirection:'row', alignItems:'center' &#125;&#125;);AppRegistry.registerComponent('ListViewDemo', () =&gt; ListViewDemo); 运行效果初始状态。onPress触发后 注意cloneWithRows接受一个数组renderRow，hightlightRow &amp; renderSeparator renderRow 的回调函数可以接受4个参数，分别是数据，区块id，行id，highlightRow回调函数 其中hightlightRow的用法文档里面写的不是很明白。搜了一下，发现是这样用的 http://stackoverflow.com/questions/36000842/how-do-i-call-highlightrow-of-listview-renderrow 大致过程是这样的，如果触发了hightlightRow(sectionID,rowID)函数，则会将该sectionID，rowID相应的单元行的标记为highlighted。而renderSeparator会检查每一个row的相邻row的highlight情况，也就是adjacentRowHighlighted 的真假。adjacentRowHighlighted默认为false 文档对renderSeparator的解释 renderSeparator function #(sectionID, rowID, adjacentRowHighlighted) =&gt; renderable如果提供了此属性，一个可渲染的组件会被渲染在每一行下面，除了小节标题的前面的最后一行。在其上方的小节ID和行ID，以及邻近的行是否被高亮会作为参数传递进来。 (sectionID, rowID, adjacentRowHighlighted) =&gt; renderableIf provided, a renderable component to be rendered as the separator below each row but not the last row if there is a section header below. Take a sectionID and rowID of the row above and whether its adjacent row is highlighted. 123&lt;View key=&#123;`$&#123;sectionID&#125;-$&#123;rowID&#125;`&#125; style=&#123;&#123;height:1,backgroundColor:adjacentRowHighlighted?'blue':'red'&#125;&#125;&gt;&lt;/View&gt; 这块代码表示了当adjacentRowHighlighted为true时，该view（分割线）的颜色为蓝色。 另外 http://wiki.jikexueyuan.com/project/react-native/image.htm 1&lt;Image source=&#123;&#123;uri:...&#125;&#125;/&gt; 中的uri的用法","tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"react-native 学习日记之ScrollView","date":"2017-02-07T09:44:54.000Z","path":"2017/02/07/学习日记/","text":"使用ScrollView 实现轮播效果还行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, Image, ScrollView&#125; from 'react-native';var Images = require('./images.json');import Dimensions from 'Dimensions';import TimerMixin from 'react-timer-mixin';var width = Dimensions.get('window').width;var ScrollViewProject = React.createClass(&#123; mixins:[TimerMixin], getInitialState() &#123; return &#123; currentPage:0 &#125; &#125;, render() &#123; return( &lt;View style=&#123;styles.container&#125;&gt; &#123;/*轮播*/&#125; &lt;ScrollView ref='scrollView' horizontal=&#123;true&#125; showsHorizontalScrollIndicator=&#123;false&#125; pagingEnabled=&#123;true&#125; onScroll=&#123;(e)=&gt;this.changeIndicators(e)&#125; onScrollBeginDrag=&#123;this.onScrollBeginDrag&#125; onScrollEndDrag=&#123;this.onScrollEndDrag&#125; &gt; &#123;this.renderAllImage()&#125; &lt;/ScrollView&gt; &#123;/*轮播指示器*/&#125; &lt;View style=&#123;styles.indicators&#125;&gt; &#123;this.renderIndicator()&#125; &lt;/View&gt; &lt;/View&gt; ); &#125;, componentDidMount() &#123; // this.setInterval( // ()=&gt;console.log('testTimeout'),1000 // ); // 开启定时器 this.startTimer(); &#125;, renderAllImage() &#123; var allImgs = []; var imgData = Images.data; var srcs = [ require(\"./imgs/a.jpg\"), require(\"./imgs/b.jpg\"), require(\"./imgs/c.jpg\"), require(\"./imgs/d.jpg\"), require(\"./imgs/e.jpg\") ]; for(let i=0;i&lt;imgData.length;i++) &#123; allImgs.push( &lt;Image key=&#123;i&#125; source=&#123;srcs[i]&#125; style=&#123;&#123;width:width,height:180&#125;&#125; /&gt; ) &#125; return allImgs; &#125;, renderIndicator() &#123; var indicators = []; for(let i=0;i&lt;5;i++) &#123; let style = (i==this.state.currentPage)?&#123;color:'#ffff00'&#125;:&#123;color:'#ffffff'&#125; indicators.push( &lt;Text key=&#123;i&#125; style=&#123;[&#123;fontSize:30,marginLeft:5&#125;,style]&#125;&gt;&amp;bull;&lt;/Text&gt; ) &#125; return indicators; &#125;, changeIndicators(e) &#123; var offsetX = e.nativeEvent.contentOffset.x; this.setState(&#123; currentPage:Math.floor(offsetX/width) &#125;) &#125;, // 设置轮播自动滚动 startTimer() &#123; // 1. 拿到scrollView var scrollView = this.refs.scrollView; // 2. 添加定时器 this.timer = this.setInterval(()=&gt;&#123; // console.log('haha'); // 2.1 设置圆点 var activePage; // 2.2 判断 if(this.state.currentPage+1 &gt;=5) activePage=0; else activePage=this.state.currentPage+1; // 2.3 更新状态 this.setState(&#123; currentPage:activePage &#125;) // 2.4 让scroll滚动起来 var offsetX = activePage * width; scrollView.scrollResponderScrollTo(&#123;x:offsetX,y:0,animated:true&#125;); &#125;,1000); &#125;, // 拖动轮播时停止定时器 onScrollBeginDrag() &#123; this.clearInterval(this.timer); &#125;, // 拖动结束后打开定时器 onScrollEndDrag() &#123; this.startTimer(); &#125;&#125;);const styles = StyleSheet.create(&#123; container: &#123; // flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', // marginTop:20 &#125;, indicators: &#123; flexDirection:'row', backgroundColor:'rgba(0,0,0,0.1)', height:30, width:width, alignItems:'center', marginTop:-30 &#125;&#125;);AppRegistry.registerComponent('ScrollViewProject', () =&gt; ScrollViewProject);","tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"'Generator 执行顺序'","date":"2016-12-26T04:13:50.000Z","path":"2016/12/26/Generator/","text":"generator 不同于普通的函数，执行方式有区别 12345678function* foo() &#123; yield 1; console.log(yield);&#125;let fooObj = foo();console.log(fooObj.next());console.log(fooObj.next());console.log(fooObj.next()); 第一个fooObj.next() 返回Object {value: 1, done: false}此时fooObj指针指向的是yield 1(第一个yield) 第二次运行fooObj.next(), 指针指向console.log(yield)中的yield即第二个yeild,此时函数返回Object {value: undefined, done: false} 第三次运行fooObj.next(), 指针继续向后移动,开始执行console.log(yield)语句,由于next参数为undefined,则指定上一次(即第二次yeild)yeild为undefined所以打印出undefined 和 Object {value: undefined, done: true}","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]}]