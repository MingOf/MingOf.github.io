[{"title":"vue 中使用iScroll","date":"2017-09-09T16:06:49.000Z","path":"2017/09/10/vue-中使用iScroll/","text":"iScroll 是一个js 多平台滚动库，https://github.com/cubiq/iscroll 这几天用下来发现这个库确实强大，github的star数也已经到达10000多。在vue中使用iScroll 和平常使用大同小异，核心思路都一样。 使用时需要注意几个问题： iScroll 需要在DOM加载完毕过后在进行初始化 DOM 更新过后要执行refresh 如果需要监听scroll事件，需要使用iscroll-probe.js版本 iScroll 只会对第一个子节点实现滚动， 其余的子节点会自动忽略 iScroll 初始化指定的节点最好有position:relative; height: 100% 初始化指定的节点可以加上transform: translate3d(0,0,0)，以此开启硬件加速 vue 组件中初始化iScroll一定要在mounted钩子函数中，并且使用this.$nextTick()回调，也可以用setTimeout延迟执iScroll的初始化 可以自己通过iScroll实现一个vue组件，可以命名为Scroll；在Scroll 的 template中使用slot插槽， 可以很方便的自行决定Scroll 下面的DOM结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;template&gt; &lt;!-- iScroll初始化指定的div --&gt; &lt;div ref=\"wrapper\" class=\"scroll-wrapper\" style=\"position:relative; -webkit-transform:translate3d(0,0,0);overflow: hidden; height: 100%\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; // 主要的数据 ，这里是属性中的data，这个数据主要来自于父组件 data: &#123; type: Array, default: function () &#123; return null &#125; &#125;, // 设置一个refreshTrigger 数据， 只要这个数据改变就执行refresh refreshTrigger: &#123; type: [String, Array, Number], default: '' &#125;, // 是否监听Scroll ，如果true， 则iscroll 使用probeType: 3 来进行初始化 // 关于probeType： https://github.com/cubiq/iscroll#optionsprobetype listenScroll: &#123; type: Boolean, default: false &#125; &#125;, // 这个是vue组件中的data，和属性中的那个data不是一个东西 data () &#123; return &#123; scroll: null, timer: 0, timer2: 0 &#125; &#125;, methods: &#123; scrollTo () &#123; this.scroll &amp;&amp; this.scroll.scrollTo.apply(this.scroll, arguments) &#125;, scrollToElement () &#123; this.scroll &amp;&amp; this.scroll.scrollToElement.apply(this.scroll, arguments) &#125;, refresh () &#123; this.scroll &amp;&amp; this.scroll.refresh() &#125; &#125;, mounted () &#123; // 这里也可以使用this.$nextTick(() =&gt; &#123; this.scroll ... &#125;) this.timer = setTimeout(() =&gt; &#123; /* eslint-disable no-new */ this.scroll = new IScroll(this.$refs.wrapper, &#123; click: true, // 是否监听Scroll ，如果true， 则iscroll 使用probeType: 3 来进行初始化； probeType: this.listenScroll ? 3 : 1, preventDefault: true, HWCompositing: true, disablePointer: true, bounce: true, elastic: true &#125;) &#125;, 20) &#125;, watch: &#123; data (value) &#123; // 必须使用setTimeout 由于refresh 也是异步的 this.timer2 = setTimeout(() =&gt; &#123; this.scroll &amp;&amp; this.scroll.refresh() &#125;, 20) &#125;, refreshTrigger () &#123; this.refresh() &#125; &#125;, destroyed () &#123; clearTimeout(this.timer) clearTimeout(this.timer2) &#125; &#125;&lt;/script&gt;&lt;style scoped lang=\"stylus\" rel=\"stylesheet/stylus\"&gt; /* solve Unable to preventDefault inside passive event listener due to target being treated as passive */ .scroll-wrapper touch-action: none;&lt;/style&gt;","tags":[]},{"title":"JavaScript高级程序设计笔记","date":"2017-08-22T16:00:00.000Z","path":"2017/08/23/JavaScript高级程序设计笔记/","text":"第 3 章 基本概念typeof 的返回值有undefined, boolean, string, number, object, function 对未初始化的变量执行 typeof 操作符会返回 undefined 值,而对未声明的变量执行 typeof 操作符同样也会返回 undefined 值 Number.MIN_VALUE 中——在大多数浏览器中,这个值是 5e-324;能够表示的最大数值保存在Number.MAX_VALUE 中——在大多数浏览器中,这个值是 1.7976931348623157e+308 0 除以 0 才会返回 NaN,正数除以 0 返回 Infinity,负数除以 0 返回-Infinity 转型函数 Number() 可以用于任何数据类型,而另两个函数则专门用于把字符串转换成数值 Number() 函数的转换规则如下: 如果是 Boolean 值, true 和 false 将分别被转换为 1 和 0。 如果是数字值,只是简单的传入和返回。 如果是 null 值,返回 0。 如果是 undefined ,返回 NaN 。 如果是字符串,遵循下列规则: 如果字符串中只包含数字(包括前面带正号或负号的情况),则将其转换为十进制数值,即 “1”会变成 1, “123” 会变成 123,而 “011” 会变成 11(注意:前导的零被忽略了); 如果字符串中包含有效的浮点格式,如 “1.1” ,则将其转换为对应的浮点数值(同样,也会忽略前导零); 如果字符串中包含有效的十六进制格式,例如 “0xf” ,则将其转换为相同大小的十进制整数值; 如果字符串是空的(不包含任何字符),则将其转换为 0; 如果字符串中包含除上述格式之外的字符,则将其转换为 NaN 。 如果是对象,则调用对象的 valueOf() 方法,然后依照前面的规则转换返回的值。如果转换的结果是 NaN ,则调用对象的 toString() 方法,然后再次依照前面的规则转换返回的字符串值。 String() 函数遵循下列转换规则: 如果值有 toString() 方法,则调用该方法(没有参数)并返回相应的结果; 如果值是 null ,则返回 “null” ; 如果值是 undefined ,则返回 “undefined” arguments 的行为,还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步 ECMAScript 中的所有参数传递的都是值,不可能通过引用传递参数 第四章 变量、作用域和内存问题执行环境定义了变量或函数有权访问的其他数据,决定了它们各自的行为 每个函数都有自己的执行环境。当执行流进入一个函数时,函数的环境就会被推入一个环境栈中。而在函数执行之后,栈将其环境弹出,把控制权返回给之前的执行环境 当代码在一个环境中执行时,会创建变量对象的一个作用域链(scope chain)。作用域链的用途,是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端,始终都是当前执行的代码所在环境的 变量对象。如果这个环境是函数,则将其活动对象(activation object)作为变量对象。活动对。作用域链中象在最开始时只包含一个变量,即 arguments 对象(这个对象在全局环境中是不存在的)的下一个变量对象来自包含(外部)环境,而再下一个变量对象则来自下一个包含环境。这样,一直延续到全局执行环境;全局执行环境的变量对象始终都是作用域链中的最后一个对象。 第五章 引用类型引用类型包括 Object,Array,Date,RegExp,Function,基本包装类型(Boolean,Number,String),单体内置对象(Global,Math) 第六章 面向对象的程序设计对象内部属性 属性 用途 默认值 [[Configurable]] 表示能否通过 delete 删除属性从而重新定义属性,能否修改属性的特性,或者能否把属性修改为访问器属性 true [[Enumerable]] 表示能否通过 for-in 循环返回属性 true [[Writable]] 表示能否修改属性的值 true [[value]] 包含这个属性的数据值 undefined 一旦把属性定义为不可配置的,就不能再把它变回可配置了。此时,再调用 Object.defineProperty() 方法修改除 writable 之外的特性,都会导致错误 理解原型 对象的方法 方法 用途 参数 Object.defineProperty() 修改属性的默认特性 属性所在的对象、属性的名字和一个描述符对象 Object.defineProperties() 一次定义多个属性 要添加和修改其属性的对象、对象的属性与第一个对象中要添加或修改的属性一一对应 Object.getOwnPropertyDescriptor() 取得给定属性的描述符 属性所在的对象和要读取其描述符的属性名称 Object.getPrototypeOf 返回[[Prototype]]的值 某个对象 obj.hasOwnProperty 只在给定属性存在于对象实例中时,才会返回 true 对象的某个属性 Object.keys 返回一个包含所有可枚举属性的字符串数组 某个对象 Object.getOwnPropertyNames 返回所有实例属性组成的数组，无论是否可枚举 某个对象 Object.create 原型式继承的规范化方法 某个对象、[对象属性的配置对象] 创建对象的方式 ：工厂模式、构造函数模式、原形模式、组合使用构造函数模式、动态原型模式、寄生构造函数模式、稳妥构造函数模式 要创建 Person 的新实例,必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下4个步骤: 创建一个新对象; 将构造函数的作用域赋给新对象(因此 this 就指向了这个新对象) 执行构造函数中的代码(为这个新对象添加属性); 返回新对象。 模式 缺点 工厂模式 没有解决对象识别的问题 构造函数模式 每个方法都会在每个实例上重新创建一遍 原型模式 会共享引用类型值的属性 组合使用构造函数模式 √ 动态原型模式 √ 寄生构造函数模式 — 稳妥构造函数模式 — 工厂模式 123456789101112function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\");var person2 = createPerson(\"Greg\", 27, \"Doctor\"); 构造函数模式 12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\"); 原型模式 123456789101112function Person()&#123;&#125;Person.prototype.name = \"Nicholas\";Person.prototype.age = 29;Person.prototype.job = \"Software Engineer\";Person.prototype.sayName = function()&#123;alert(this.name);&#125;;var person1 = new Person();person1.sayName();//\"Nicholas\"var person2 = new Person(); 组合使用构造函数模式 1234567891011121314151617181920212223function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [\"Shelby\", \"Court\"];&#125;Person.prototype = &#123; constructor : Person, sayName : function()&#123; alert(this.name); &#125; &#125;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\");person1.friends.push(\"Van\");alert(person1.friends);//\"Shelby,Count,Van\"alert(person2.friends);//\"Shelby,Count\"alert(person1.friends === person2.friends);//falsealert(person1.sayName === person2.sayName);//true 动态原型模式 123456789101112131415function Person(name, age, job)&#123; //属性 this.name = name; this.age = age; this.job = job; //方法 if (typeof this.sayName != \"function\")&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125;&#125;var friend = new Person(\"Nicholas\", 29, \"Software Engineer\");friend.sayName(); 重写原型对象会切断现有原型与任何之前已经存在的对象实例之间的联系;它们引用的仍然是最初的原型 继承方式：原型链、借用构造函数模式、组合继承、原型式继承、寄生式继承、寄生组合式继承 继承方式 优缺点 原型链 引用类型值的原型属性会被所有实例共享 ，在创建子类型的实例时,不能向超类型的构造函数中传递参数 借用构造函数 函数无法复用 组合继承 √，但超类构造函数会被调用两次 原型式继承 — 寄生式继承 — 寄生组合式继承 √，解决了组合继承两次调用的问题 原型链继承 1234567891011121314151617181920function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue());//true 借用构造函数继承 1234567891011121314function SuperType()&#123; this.colors = [\"red\", \"blue\", \"green\"];&#125;function SubType()&#123;//继承了 SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(\"black\");alert(instance1.colors);//\"red,blue,green,black\"var instance2 = new SubType();alert(instance2.colors);//\"red,blue,green\" 组合继承 12345678910111213141516171819202122232425262728293031323334function SuperType(name)&#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; //继承属性 SuperType.call(this, name); this.age = age;&#125;//继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;var instance1 = new SubType(\"Nicholas\", 29);instance1.colors.push(\"black\");alert(instance1.colors);//\"red,blue,green,black\"instance1.sayName();//\"Nicholas\";instance1.sayAge();//29var instance2 = new SubType(\"Greg\", 27);alert(instance2.colors);//\"red,blue,green\"instance2.sayName();//\"Greg\";instance2.sayAge();//27 原型式继承 12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 寄生式继承 1234567function createAnother(original)&#123; var clone = object(original); clone.sayHi = function()&#123; alert(\"hi\"); &#125;; return clone;&#125; 寄生组合式继承 1234567891011121314151617181920function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;&#125;function SuperType(name)&#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"数组去重","date":"2017-08-21T15:18:27.000Z","path":"2017/08/21/优化的数组去重/","text":"传统数组去重123456789Array.prototype.unique = function() &#123; var a = [], l = this.length; for(var i=0; i&lt;l; i++) &#123; for(var j=i+1; j&lt;l; j++) if (this[i] === this[j]) j = ++i; a.push(this[i]); &#125; return a;&#125;; 优化数组去重方法,利用对象的键名不重复来筛选数组123456Array.prototype.unique = function() &#123; var o = &#123;&#125;, i, l = this.length, r = []; for(i=0; i&lt;l;i+=1) o[this[i]] = this[i]; for(i in o) r.push(o[i]); return r;&#125;; 还有一种比较简便的方法1234567function unique1(array)&#123; var n = []; for(var i = 0; i &lt; array.length; i++)&#123; if (n.indexOf(array[i]) == -1) n.push(array[i]); &#125; return n;&#125; 最后还有一个最简便的方法1var a = [new Set(someArray)] 后两种需要考虑兼容性, 但是比较简便,第二个方法的性能完胜第一个","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"react 个人小项目开发question","date":"2017-08-19T02:18:37.000Z","path":"2017/08/19/react-个人小项目开发question/","text":"React Component Lifecyclehttps://solome.js.org/web/react/2016/11/30/react-lifecycle.html React.createElement: type is invalid – expected a string or a class/function but got: undefinedresolution: 12345678910&lt;Menu.Item key='logout' className='register'&gt; &lt;Button type=\"primary\"&gt;&#123;this.state.username&#125;&lt;/Button&gt; &amp;nbsp;&amp;nbsp; &#123;/* &lt;Link target='_blank'&gt;&lt;Button type='dashed'&gt;个人中心&lt;/Button&gt;&lt;/Link&gt; */&#125; &lt;Button type=\"ghost\"&gt;退出&lt;/Button&gt;&lt;/MenuItem&gt;//error:&lt;Menu.Item key='register' className='register'&gt; &lt;Icon type=\"appstore\"/&gt;注册/登录&lt;/MenuItem&gt; to 123456789101112...const MenuItem = Menu.Item;&lt;MenuItem key='logout' className='register'&gt; &lt;Button type=\"primary\"&gt;&#123;this.state.username&#125;&lt;/Button&gt; &amp;nbsp;&amp;nbsp; &#123;/* &lt;Link target='_blank'&gt;&lt;Button type='dashed'&gt;个人中心&lt;/Button&gt;&lt;/Link&gt; */&#125; &lt;Button type=\"ghost\"&gt;退出&lt;/Button&gt;&lt;/MenuItem&gt;:&lt;MenuItem key='register' className='register'&gt; &lt;Icon type=\"appstore\"/&gt;注册/登录&lt;/MenuItem&gt; Warning: Failed context type: The context router is marked as required in Link, but its value is undefined.resolution: change /src/root.js12345678&lt;div&gt; &lt;MediaQuery query='(min-device-width:997px)'&gt; &lt;PCIndex /&gt; &lt;/MediaQuery&gt; &lt;MediaQuery query='(max-device-width:997px)'&gt; &lt;MobileIndex /&gt; &lt;/MediaQuery&gt;&lt;/div&gt; to 12345678910&lt;Router&gt; &lt;div&gt; &lt;MediaQuery query='(min-device-width:997px)'&gt; &lt;PCIndex /&gt; &lt;/MediaQuery&gt; &lt;MediaQuery query='(max-device-width:997px)'&gt; &lt;MobileIndex /&gt; &lt;/MediaQuery&gt; &lt;/div&gt;&lt;/Router&gt; how to modify themes of ant design via third-party or custom webpackConfigresolution: change webpack.config.js to1234567891011121314151617181920212223242526272829&#123; test: /\\.js?$/, exclude: /(node_modules)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['react','es2015'], // ant design babel-plugin-import plugins: [['import',&#123;'libraryName':'antd','style':true&#125;]] &#125; &#125;&#125;,&#123; test: /\\.less$/, include: path.resolve(__dirname, './node_modules'), use: [ 'style-loader', 'css-loader', &#123; loader: 'less-loader', options: &#123; // add less-loader option 'modifyVars' to change less var that defined in ant-design css modifyVars: &#123; \"primary-color\": '#1da57a' &#125; &#125; &#125; ]&#125; loading static sources (images) with webpackresolutions: add rules like this1234567891011&#123; test: /\\.(png|jpe?g|gif|svg)$/, exclude: /(node_modules)/, use: &#123; loader: 'url-loader', options: &#123; limit: 8192, name: 'img/[hash:5].[ext]' &#125; &#125;&#125; now can use require(...) or ‘import’ to load images by relative path in jsx; how to use css media query in css-moduleshttps://npm.taobao.org/package/postcss-modules-values cannot read videos of nullwhen map the this.state.videosresolution:add this.state={...} to constructor 1234567891011constructor() &#123;&#125;toconstructor() &#123; this.state= &#123; videos: ''; &#125;&#125; how to use Promise.all to fetch two urls simultaneouslyrefer to: https://segmentfault.com/q/1010000004101262/a-1020000004101642 how to use BMap with webpackresolution:add option externals to the end of webpack-config.js12345678module.exports = &#123; ... entry... output... externals: &#123; 'BMap': 'BMap' &#125;&#125; and then import BMap from &#39;BMap&#39; when you need; where to find svg picspixabay.com this.props.dispatch is not a functionwhen using react-redux to connect store and component;resolution: explicitly return it yourself in mapDispatchToProps implementation;12345const mapDispatchToProps = (dispatch,ownProps) =&gt; &#123; return &#123; \"dispatch\": dispatch, &#125;&#125; ant design Carousel component connot autoplay when using react-redux to connect component which has imported the Carouselresolution:dont use “connect” for Carousel contained components; ant design Tabs animated lag during switch tabpane via big datado not forget to call callback in the validator of Form.Item when you call this.props.form.validateFields or this.props.form.validateFieldsAndScroll with a Form.Item which contains a validator’s callback not called123456789101112131415&#123;getFieldDecorator('r_confirm',&#123; rules: [&#123; required: true, message: '请确认密码' &#125;, &#123; validator: (rule, value, callback) =&gt; &#123; if(value &amp;&amp; value!==this.props.form.getFieldValue('r_password')) &#123; callback('密码不一致') &#125; &#125; &#125;]&#125;)( &lt;Input type=\"password\" placeholder='请确认您的密码' /&gt;)&#125; is not equal to:12345678910111213141516&#123;getFieldDecorator('r_confirm',&#123; rules: [&#123; required: true, message: '请确认密码' &#125;, &#123; validator: (rule, value, callback) =&gt; &#123; if(value &amp;&amp; value!==this.props.form.getFieldValue('r_password')) &#123; callback('密码不一致') &#125; callback() &#125; &#125;]&#125;)( &lt;Input type=\"password\" placeholder='请确认您的密码' /&gt;)&#125; nodejs server router is in conflict with react-router BrowserRouterresolution:use HashRouter instead of BrowserRouter or manualy set histroyFallbackhttp://www.cnblogs.com/YZH-chengdu/p/6855237.html textarea height auto increment1234567891011121314151617181920212223(() =&gt; &#123; // textarea height auto increment var textarea = document.getElementById('textarea'); // hide scroll bar textarea.style.overflow = 'hidden'; var height = parseInt(window.getComputedStyle(textarea).height); var width = parseInt(window.getComputedStyle(textarea).width); var autoHeight = function() &#123; if(this.scrollHeight &lt;= height || this.value == '') &#123; this.style.height=height + 'px'; return; &#125; this.style.height = this.scrollHeight + 'px'; &#125; textarea.oninput = autoHeight; textarea.onpropertychange = function (event) &#123; if(event.propertyName.toLowerCase() == 'value') &#123; autoHeight(); console.log(this.value); &#125; &#125;&#125;)()","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"textarea 实现高度自动增长","date":"2017-08-19T01:50:30.000Z","path":"2017/08/19/textarea-实现高度自动增长/","text":"有时候希望textarea 能够自动调整高度来适应输入的内容 网上看到了很多解决方案，比如动态创建一个隐藏的div，当用户输入的时候将textarea的内容绑定到div，由于div的高度会自动撑开，因此可以动态检测div的高度，然后将div的高度复制给textarea。这个方法应该是兼容性较好而且比较稳健的办法，但实在太繁琐 还有一个解决办法就是动态将textarea的scrollHeight 复制给高度。我采用的是后者 1234567891011121314var textarea = document.getElementById('textarea'); // hide scroll bartextarea.style.overflow = 'hidden';var height = parseInt(window.getComputedStyle(textarea).height);var width = parseInt(window.getComputedStyle(textarea).width);var autoHeight = function() &#123; if(this.scrollHeight &lt;= height || this.value == '') &#123; this.style.height=height + 'px'; return; &#125; this.style.height = this.scrollHeight + 'px';&#125;textarea.oninput = autoHeight; 这个方法就是通过监听textarea的oninput 来实现，也可以监听keyup，keydown；但是如果使用keyup或者keydown来监听的话会存在一个问题，那就是如果textarea有复制或者剪切操作，keyup，keydown不会立即响应内容的变化，并且也不能响应鼠标右键粘贴。 最后再象征性地增加兼容123456textarea.onpropertychange = function (event) &#123; if(event.propertyName.toLowerCase() == 'value') &#123; autoHeight(); console.log(this.value); &#125;&#125; 然而悲伤的是这种方式并不适用移动端，移动端所有浏览器均测试无效 另外还有一个解决办法就是不使用textarea，而是使用普通div模拟textarea，因为div本身高度就自动增长，所有就不用担心其他问题了。实现方式就是给div设置属性contentEditable=true，这样div就变为可编辑的了。不过这种方式在某些firefox上面，div外层会出现虚框，从而使得div的本质暴露无疑。解决办法就是css配置outline:0 none","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"react-router V4 踩坑","date":"2017-08-01T02:59:12.000Z","path":"2017/08/01/react-router-V4-踩坑/","text":"The prop `history` is marked as required in `Router` …The prop `history` is marked as required in `Router`, but its value is `undefined`. in Router 解决办法:出现这个报错是因为我用npm 安装的是react-router v4，react-router v4不再使用&lt;Router history={hashHistory}&gt; 这种方式定义history 实现类型。而是直接通过组件如BrowserRouter,HashRouter等 123456789101112131415161718import &#123;Router, Route, hashHistory&#125; from 'react-router';&lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;Main&#125;&gt;&lt;/Route&gt;&lt;/Router&gt;===&gt;import &#123;BrowserRouter as Router, Route&#125; from 'react-router-dom';&lt;Router&gt; &lt;Route path=\"/\" component=&#123;Main&#125;&gt;&lt;/Route&gt;&lt;/Router&gt;或者&lt;HashRouter&gt; &lt;Route path=\"/\" component=&#123;Main&#125;&gt;&lt;/Route&gt;&lt;/HashRouter&gt; A ‘Router’ may have only one child elementreact-router v4 在 下面只能放一个层级，类似与react 中render 不能有两个平级div一样 解决办法：用div 或者Switch 包裹所有Route12345678&lt;Router&gt; &lt;div&gt; &lt;Route component=&#123;ComponentHeader&#125;&gt;&lt;/Route&gt; &lt;Switch&gt; &lt;Route component=&#123;ComponentFooter&#125; path='/footer/:id'&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt;&lt;/Router&gt; webpack 配置问题v4 中引入&lt;BrowserRouter&gt; 组件, 而BrowserRouter使用的是HTML5 的history api, 在使用webpack-dev-server时会遇到 GET http://localhost:8080/xxx/xxx 404 (Not Found) 解决办法：webpack.config.js中加入1234567devServer: &#123; apiHistoryFallback: true,&#125;output: &#123; ..., publicPath: '/',&#125; 然后将index.html中的bundle.js改为/bundle.js 1&lt;script src='bundle.js'&gt;&lt;/script&gt; ===&gt; &lt;script src='/bundle.js'&gt;&lt;/script&gt; 参考：https://stackoverflow.com/questions/43209666/react-router-v4-cannot-get-url questionhttps://segmentfault.com/q/1010000010432084?_ea=2287891 静态路由和动态路由https://reacttraining.com/react-router/web/guides/philosophy react-router 传参使用/xxx/:someparam 的形式书写Route 的path属性，如：1&lt;Route component=&#123;ComponentFooter&#125; path='/footer/:id'&gt;&lt;/Route&gt; 然后Link 的to属相加上参数即可，如： 1&lt;Link to='/footer/1234'&gt;Ant design demo 1&lt;/Link&gt; 最后在ComponentFooter中通过this.props.match.params访问，如： 123&lt;footer className=&#123;footerCss.miniFooter&#125;&gt; &lt;em&gt;id:&#123;this.props.match.params.id&#125;&lt;/em&gt;&lt;/footer&gt; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * js| * |root.js */import React from 'react';import ReactDOM from 'react-dom';import ComponentHeader from './components/header';// import ComponentFooter from './components/footer';var footerCss = require('../css/footer.css');import &#123;BrowserRouter as Router, Route, Switch, Link&#125; from 'react-router-dom';class App extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;Route component=&#123;ComponentHeader&#125;&gt;&lt;/Route&gt; &lt;Switch&gt; &lt;Route component=&#123;ComponentFooter&#125; path='/footer/:id'&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;class ComponentFooter extends React.Component &#123; constructor() &#123; super(); &#125; render() &#123; return ( &lt;footer className=&#123;footerCss.miniFooter&#125;&gt; &lt;em&gt;id:&#123;this.props.match.params.id&#125;&lt;/em&gt; &lt;h1&gt;&lt;Link to=&#123;`$&#123;this.props.match.url&#125;/cr`&#125;&gt;footer&lt;/Link&gt;&lt;/h1&gt; &lt;Route component=&#123;CopyRight&#125; path=&#123;`$&#123;this.props.match.url&#125;/cr`&#125;&gt;&lt;/Route&gt; &lt;/footer&gt; ) &#125;&#125;class CopyRight extends React.Component &#123; constructor() &#123; super(); &#125; render() &#123; return ( &lt;a&gt;copyright&lt;/a&gt; ) &#125;&#125;ReactDOM.render( &lt;App /&gt;,document.getElementById('root'))/** * js| * |components| * |header.js */import React from 'react';import &#123;Link&#125; from 'react-router-dom';var headerCss = require('../../css/header.css');export default class Header extends React.Component &#123; constructor() &#123; super(); &#125; render() &#123; console.log(headerCss); return ( &lt;header className=&#123;headerCss.bgheader&#125;&gt; &lt;h1&gt;&lt;Link to='/footer/1234'&gt;Ant design demo 1&lt;/Link&gt;&lt;/h1&gt; &lt;/header&gt; ) &#125;&#125;","tags":[]},{"title":"webpack css-modules 和global css 共存","date":"2017-07-30T09:29:14.000Z","path":"2017/07/30/webpack-css-modules-和global-css-共存/","text":"在使用ant design 时候遇到ant design css 和自定义的css 冲突的问题。./node_modules/ 中ant desing 的css 文件作为全局的css 和 自定义的css_modules 会发生冲突。解决办法是将/node_modules/中的css与自定义的css 分开处理。即对css_modules使用exclude:/node_modules/，对node_modules中的css使用include:path.resolve(__dirname,&#39;node_modules&#39;) 最开始定义的webpack.config.js 的处理方式：123456789101112131415161718192021222324252627282930313233343536373839404142var webpack = require('webpack');var path = require('path');module.exports = &#123; context: __dirname+'/src', entry: \"./js/index.js\", module: &#123; rules: [ &#123; test: /\\.js?$/, exclude: /(node_modules)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['react','es2015'], // ant design babel-plugin-import plugins: [['import',&#123;'libraryName':'antd','style':'css'&#125;]] &#125; &#125; &#125;, &#123; test: /\\.css$/, exclude: /(node_modules)/, use: [ &#123;loader:'style-loader'&#125;, &#123; loader: 'css-loader', options: &#123; modules: true, loacalIdentName: '[name]__[local]_[hash:base64:5]', sourceMap: true, importLoaders: 1 &#125; &#125; ] &#125;, ] &#125;, output: &#123; path: __dirname+'/src', filename: 'bundle.js' &#125;&#125; 报错： ERROR in ./node_modules/antd/lib/button/style/index.cssModule parse failed: /home/johnny/Project/react/demo3/node_modules/antd/lib/button/style/index.css Unexpected token (1:0)You may need an appropriate loader to handle this file type. 找到解决办法是，分别处理node_modules(ant design)中的css和css_modules：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var webpack = require('webpack');var path = require('path');module.exports = &#123; context: __dirname+'/src', entry: \"./js/index.js\", module: &#123; rules: [ &#123; test: /\\.js?$/, exclude: /(node_modules)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['react','es2015'], plugins: [['import',&#123;'libraryName':'antd','style':'css'&#125;]] &#125; &#125; &#125;, // css_modules 处理方式 &#123; test: /\\.css$/, exclude: /(node_modules)/, use: [ &#123;loader:'style-loader'&#125;, &#123; loader: 'css-loader', options: &#123; modules: true, loacalIdentName: '[name]__[local]_[hash:base64:5]', sourceMap: true, importLoaders: 1 &#125; &#125; ] &#125;, // ant design 处理方式 &#123; test: /\\.css$/, include: path.resolve(__dirname, 'node_modules'), use: [ &#123;loader:'style-loader'&#125;, &#123; loader:'css-loader', &#125; ] &#125;, ] &#125;, output: &#123; path: __dirname+'/src', filename: 'bundle.js' &#125;&#125;","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"react-native学习日记之TabNavigator","date":"2017-02-27T05:11:59.000Z","path":"2017/02/27/react-native学习日记之TabNavigator/","text":"安卓中不能像IOS一样有NavigatorIOS和tabBarIOS，如果需要跨平台实现类似的功能，必须要借助第三方组件如https://github.com/exponent/react-native-tab-navigator 安装： npm install react-native-tab-navigator 使用： import TabNavigator from &#39;react-native-tab-navigator&#39; 这个组件的使用方式类似于TabBarIOS，配合Navigator一起使用就可以到达跨平台的效果了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, Image, Navigator&#125; from 'react-native';import TabNavigator from 'react-native-tab-navigator';import HomeView from './Components/homeView.js';import ProfileView from './Components/profileView.js';var icons=[ require('./imgs/tabbar_1.png'), require('./imgs/tabbar_2.png'), require('./imgs/tabbar_3.png'), require('./imgs/tabbar_4.png')];var pressIcons = [ require('./imgs/tabbar_1_press.png'), require('./imgs/tabbar_2_press.png'), require('./imgs/tabbar_3_press.png'), require('./imgs/tabbar_4_press.png')]export default class TabNavigatorDemo extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; selectedTab:'home' &#125; &#125; render() &#123; let defaultName = 'HomeView'; let defaultComponent = HomeView; return ( &lt;View style=&#123;&#123;flex:1&#125;&#125;&gt; &lt;TabNavigator tabBarStyle=&#123;styles.tabBarStyle&#125;&gt; &lt;TabNavigator.Item selected=&#123;this.state.selectedTab === 'home'&#125; title=\"Home\" renderIcon=&#123;() =&gt; &lt;Image style=&#123;styles.iconStyle&#125; source=&#123;icons[0]&#125; /&gt;&#125; renderSelectedIcon=&#123;() =&gt; &lt;Image style=&#123;styles.iconStyle&#125; source=&#123;pressIcons[0]&#125; /&gt;&#125; badgeText=\"1\" onPress=&#123;() =&gt; this.setState(&#123; selectedTab: 'home' &#125;)&#125;&gt; &lt;Navigator initialRoute=&#123;&#123;name:defaultName,component:defaultComponent&#125;&#125; configureScene=&#123;(route)=&gt;&#123; return Navigator.SceneConfigs.VerticalDownSwipeJump; &#125;&#125; renderScene=&#123;(route,navigator)=&gt;&#123; // console.log(route,navigator); let Component = route.component; return &lt;Component &#123;...route.params&#125; navigator=&#123;navigator&#125; /&gt; &#125;&#125; navigationBar=&#123; &lt;Navigator.NavigationBar routeMapper=&#123;&#123; LeftButton: (route,navigator,index,navState)=&gt;&#123; return (&lt;Text&gt;前进&lt;/Text&gt;); &#125;, Title: (route,navigator,index,navState)=&gt;&#123; return (&lt;Text&gt;首页&lt;/Text&gt;); &#125;, RightButton: (route, navigator, index, navState) =&gt; &#123;&#125;, &#125;&#125; /&gt; &#125; /&gt; &lt;/TabNavigator.Item&gt; &lt;TabNavigator.Item selected=&#123;this.state.selectedTab === 'profile'&#125; title=\"Profile\" renderIcon=&#123;() =&gt; &lt;Image style=&#123;styles.iconStyle&#125; source=&#123;icons[1]&#125; /&gt;&#125; renderSelectedIcon=&#123;() =&gt; &lt;Image style=&#123;styles.iconStyle&#125; source=&#123;pressIcons[1]&#125; /&gt;&#125; // renderBadge=&#123;() =&gt; &lt;CustomBadgeView /&gt;&#125; onPress=&#123;() =&gt; this.setState(&#123; selectedTab: 'profile' &#125;)&#125;&gt; &lt;ProfileView/&gt; &lt;/TabNavigator.Item&gt; &lt;TabNavigator.Item selected=&#123;this.state.selectedTab === 'favor'&#125; title=\"favor\" renderIcon=&#123;() =&gt; &lt;Image style=&#123;styles.iconStyle&#125; source=&#123;icons[2]&#125; /&gt;&#125; renderSelectedIcon=&#123;() =&gt; &lt;Image style=&#123;styles.iconStyle&#125; source=&#123;pressIcons[2]&#125; /&gt;&#125; // renderBadge=&#123;() =&gt; &lt;CustomBadgeView /&gt;&#125; onPress=&#123;() =&gt; this.setState(&#123; selectedTab: 'favor' &#125;)&#125;&gt; &lt;ProfileView/&gt; &lt;/TabNavigator.Item&gt; &lt;TabNavigator.Item selected=&#123;this.state.selectedTab === 'me'&#125; title=\"me\" renderIcon=&#123;() =&gt; &lt;Image style=&#123;styles.iconStyle&#125; source=&#123;icons[3]&#125; /&gt;&#125; renderSelectedIcon=&#123;() =&gt; &lt;Image style=&#123;styles.iconStyle&#125; source=&#123;pressIcons[3]&#125; /&gt;&#125; // renderBadge=&#123;() =&gt; &lt;CustomBadgeView /&gt;&#125; onPress=&#123;() =&gt; this.setState(&#123; selectedTab: 'me' &#125;)&#125;&gt; &lt;ProfileView/&gt; &lt;/TabNavigator.Item&gt; &lt;/TabNavigator&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; tabBarStyle: &#123; // backgroundColor:'red' &#125;, iconStyle: &#123; width:20, height:20 &#125;&#125;);AppRegistry.registerComponent('TabNavigatorDemo', () =&gt; TabNavigatorDemo);","tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"react-native学习日记之tabBar","date":"2017-02-22T03:44:59.000Z","path":"2017/02/22/react-native学习日记之tabBar/","text":"IOS 上可以使用tabBarIOS组件实现底栏tabBar，但是安卓不行。不过可以借助第三方组件实现类似的功能react-native-tab-view 基本用法如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View&#125; from 'react-native';import &#123;TabViewAnimated,TabBar&#125; from 'react-native-tab-view';export default class tabView extends Component &#123; state = &#123; index: 0, routes: [ &#123; key: '1', title: 'First' &#125;, &#123; key: '2', title: 'Second' &#125;, ], &#125;; _handleChangeTab = (index) =&gt; &#123; this.setState(&#123;index&#125;); &#125;; _renderHeader = (props) =&gt; &#123; console.log(TabBar); return &lt;TabBar &#123;...props&#125; style=&#123;styles.tabBar&#125;/&gt; &#125;; _renderFooter = (props) =&gt; &#123; console.log(TabBar); return &lt;TabBar &#123;...props&#125; style=&#123;styles.tabBar&#125; indicatorStyle=&#123;&#123;backgroundColor:'transparent'&#125;&#125;/&gt; &#125;; _renderScene = (&#123;route&#125;) =&gt; &#123; switch (route.key) &#123; case '1': return &lt;View style=&#123;[styles.page,&#123;backgroundColor:'#ff4081'&#125;]&#125;&gt; &lt;Text&gt; 第一页 &lt;/Text&gt; &lt;/View&gt; case \"2\": return &lt;View style=&#123;[styles.page,&#123;backgroundColor:'#673ab7'&#125;]&#125;&gt; &lt;Text&gt; 第二页 &lt;/Text&gt; &lt;/View&gt; default: return null; &#125; &#125;; render() &#123; return ( &lt;TabViewAnimated style=&#123;styles.container&#125; navigationState=&#123;this.state&#125; renderScene=&#123;this._renderScene&#125; renderHeader=&#123;this._renderHeader&#125; // renderFooter=&#123;this._renderFooter&#125; onRequestChangeTab=&#123;this._handleChangeTab&#125; /&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, &#125;, page: &#123; flex: 1, alignItems: 'center', justifyContent: 'center', &#125;,&#125;);AppRegistry.registerComponent('tabView', () =&gt; tabView);","tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"atom package清单","date":"2017-02-19T07:35:16.000Z","path":"2017/02/19/atom-package清单/","text":"做个备份123456789101112131415161718192021222324252627282930313233Community Packages (32) /home/johnny/.atom/packages├── atom-material-syntax@1.0.2├── atom-material-ui@1.3.9├── atom-react-native-autocomplete@0.0.27├── atom-react-native-css@1.1.3├── atom-ternjs@0.17.0├── autoclose-html@0.23.0├── autocomplete-modules@1.6.7├── autocomplete-paths@1.0.5├── autoprefixer@3.6.1├── color-picker@2.2.5├── emmet@2.4.3├── file-icons@2.0.15├── fold-functions@0.5.0├── highlight-selected@0.12.0├── jquery-snippets@11.0.0├── language-babel@2.54.1├── language-javascript-jsx@0.3.7├── linter@1.11.21├── linter-csslint@1.3.3├── linter-htmlhint@1.3.1├── linter-js-standard-jsx@4.1.2├── linter-jshint@3.0.2├── markdown-preview-plus@2.4.1├── markdown-scroll-sync@2.1.2├── markdown-table-formatter@2.8.4├── minimap@4.26.8├── minimap-highlight-selected@4.5.0├── nuclide@0.205.0├── pigments@0.39.0├── react@0.16.2├── react-es6-snippets@0.3.0└── run-in-browser@0.1.3","tags":[{"name":"atom","slug":"atom","permalink":"http://yoursite.com/tags/atom/"}]},{"title":"react-native学习日记之ListView三","date":"2017-02-19T06:42:05.000Z","path":"2017/02/19/react-native学习日记之ListView三/","text":"ListView with SectionHeader要实现拥有section header 的ListView，需要dataBlob数据结构和renderSectionHeader 属性 dataBlobdataBlob是一个数据结构（通常是一个对象），包含了渲染ListView的所有数据。其中包括Section Header 数据和每个行Row的行数据Row Data。要获得dataBlob中的数据，首先要实现遍历方法(getSectionData 和 getRowData) dataBlob结构： 实现getSectionData 和 getRowData 1234567891011121314151617constructor(props) &#123; super(props); var getSectionData = (dataBlob,sectionID) =&gt; &#123; return dataBlob[sectionID]; &#125; var getRowData = (dataBlob,sectionID,rowID) =&gt; &#123; return dataBlob[sectionID+':'+rowID]; &#125; this.state = &#123; dataSource: new ListView.DataSource(&#123; getSectionData:getSectionData, getRowData:getRowData, rowHasChanged: (r1,r2)=&gt;r1!==r2, sectionHeaderHasChanged:(s1,s2)=&gt;s1!==s2 &#125;) &#125;&#125; 处理外部json数据，生成dataBlobjson数据如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; \"data\": [ &#123; \"images\": [ &#123; \"icon\": \"a\", \"name\": \"路飞\" &#125;, &#123; \"icon\": \"b\", \"name\": \"阿里\" &#125;, &#123; \"icon\": \"c\", \"name\": \"。。。\" &#125;, &#123; \"icon\": \"d\", \"name\": \"风景\" &#125;, &#123; \"icon\": \"e\", \"name\": \"女神(づ￣ 3￣)づ\" &#125; ], \"title\": \"B\" &#125;, &#123; \"images\": [ &#123; \"icon\": \"a\", \"name\": \"路飞\" &#125;, &#123; \"icon\": \"b\", \"name\": \"阿里\" &#125;, &#123; \"icon\": \"c\", \"name\": \"。。。\" &#125;, &#123; \"icon\": \"d\", \"name\": \"风景\" &#125;, &#123; \"icon\": \"e\", \"name\": \"女神(づ￣ 3￣)づ\" &#125; ], \"title\": \"B\" &#125;, ... ]&#125; 1234567891011121314151617181920212223242526272829303132loadDataFromJson() &#123; var data = require('./data.json').data; console.log(data); var dataBlob = &#123;&#125;, sectionIDs = []; //存放组ID的数组 rowIDs = []; //存放行ID的数组 rows = []; //存放行数据数组 for(var i=0,l=data.length;i&lt;l;i++) &#123; // 1.把section id 放入sectionID数组中 var sectionID = i; // sectionIDs.push(sectionID); sectionIDs.push(i); //sectionID 不一定必须是i：0,1,2,3... // 2. 把组中内容放入dataBlob中 // 相当于dataBlob[SectionID]=data[i].title dataBlob[i]=data[i].title; // 3. 取出该数组中所有的行数据 rows = data[i].images; // 4. 记录每一行中的数据 rowIDs[i]=[]; // 5. 获取行中每一组数据 for(var j=0,lr=rows.length;j&lt;lr;j++)&#123; // 把行号放入rowIDs中 rowIDs[i].push(j); // 把每一行中的内容放如dataBlob对象中 dataBlob[i+':'+j] = rows[j]; &#125; &#125; console.log(dataBlob,sectionIDs,rowIDs); this.setState(&#123; dataSource: this.state.dataSource.cloneWithRowsAndSections(dataBlob,sectionIDs,rowIDs) &#125;);&#125; 可以看到将dataBlob，sectionIDs，rowIDs打印出来是如下结果 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * 吸顶效果 */import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, ListView, TouchableOpacity, Image,&#125; from 'react-native';export default class ListViewSectionHeader extends Component &#123; constructor(props) &#123; super(props); var getSectionData = (dataBlob,sectionID) =&gt; &#123; return dataBlob[sectionID]; &#125; var getRowData = (dataBlob,sectionID,rowID) =&gt; &#123; return dataBlob[sectionID+':'+rowID]; &#125; this.state = &#123; dataSource: new ListView.DataSource(&#123; getSectionData:getSectionData, getRowData:getRowData, rowHasChanged: (r1,r2)=&gt;r1!==r2, sectionHeaderHasChanged:(s1,s2)=&gt;s1!==s2 &#125;) &#125; &#125; render() &#123; return ( &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this.renderRow&#125; renderSectionHeader=&#123;this.renderSectionHeader&#125; /&gt; ); &#125; componentDidMount() &#123; this.loadDataFromJson(); &#125; loadDataFromJson() &#123; var data = require('./data.json').data; console.log(data); var dataBlob = &#123;&#125;, sectionIDs = []; //存放组ID的数组 rowIDs = []; //存放行ID的数组 rows = []; //存放行数据数组 for(var i=0,l=data.length;i&lt;l;i++) &#123; // 1.把section id 放入sectionID数组中 var sectionID = i; // sectionIDs.push(sectionID); sectionIDs.push(i); //sectionID 不一定必须是i：0,1,2,3... // 2. 把组中内容放入dataBlob中 // 相当于dataBlob[SectionID]=data[i].title dataBlob[i]=data[i].title; // 3. 取出该数组中所有的行数据 rows = data[i].images; // 4. 记录每一行中的数据 rowIDs[i]=[]; // 5. 获取行中每一组数据 for(var j=0,lr=rows.length;j&lt;lr;j++)&#123; // 把行号放入rowIDs中 rowIDs[i].push(j); // 把每一行中的内容放如dataBlob对象中 dataBlob[i+':'+j] = rows[j]; &#125; &#125; console.log(dataBlob,sectionIDs,rowIDs); this.setState(&#123; dataSource: this.state.dataSource.cloneWithRowsAndSections(dataBlob,sectionIDs,rowIDs) &#125;); &#125; renderRow(owData,sectionID,rowID,highlightRow) &#123; console.log(owData); return( &lt;TouchableOpacity activeOpacity=&#123;0.5&#125;&gt; &lt;View style=&#123;styles.innerViewStyle&#125;&gt; &lt;Image source=&#123;&#123;uri:owData.icon&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt; &lt;Text style=&#123;styles.descStyle&#125;&gt; &#123;owData.name&#125; &lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ); &#125; renderSectionHeader(sectionData,sectionID) &#123; return( &lt;View style=&#123;styles.secHeaderStyle&#125;&gt; &lt;Text&gt; &#123;sectionData&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; innerViewStyle: &#123; flexDirection:'row' &#125;, iconStyle: &#123; width: 100, height: 100, &#125;, descStyle: &#123; fontSize: 20, alignSelf:'center', marginLeft:20 &#125;, secHeaderStyle: &#123; height:30, justifyContent:'center', paddingLeft:10, backgroundColor:\"#ede1e1\" &#125;&#125;);AppRegistry.registerComponent('ListViewSectionHeader', () =&gt; ListViewSectionHeader); 最终效果很难看，不过实现方式没错就行啦","tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"ubuntu 14.04配置","date":"2017-02-17T15:05:15.000Z","path":"2017/02/17/ubuntu配置/","text":"最近又尝试从Windows 切换到 ubuntu 。经过很多次折腾，发现自己对linux 有了一定的理解过后再去接触这些，已经不再那么陌生和“恐惧”了 安装Windows 10 和 ubuntu 共存安装参考 切换显卡系统设置–&gt; 软件和更行 –&gt; 附加驱动（据说开源驱动性能虽然不强，但是稳定性好，我还是继续用开源驱动吧） 换主题unity乳齿便秘的默认主题真的让我第一次开机看到它过后就想换掉！ubuntu14.04的主题很多不是扁平化的，如果电脑支持的话还是安装16.04比较好（该死的联想z485） 首先安装unity-tweak-tool1sudo apt install unity-tweak-tool 然后推荐去noobSlab，这个网站有很多个主题可以选择，安装方式也写出来了，配合unity-tweak-tool使用。个人喜欢Numix主题 安装搜狗输入法去搜狗官网下载linux 版本搜狗，然后双击安装，完毕后。系统设置–&gt;语言支持–&gt;键盘输入方式系统：fcitx–&gt;重启 如果发现安装好后不能调出输入法面板，输入时只能看不到候选词，那么可以检查一下依赖sudo apt-get install -f 如果使用一段时间过后搜狗输入法一直崩溃,可能是配置文件出问题了，可以选择删除配置文件，然后重启fctix12345killall fctixrm -rf ~/.config/sogou-qimpanelrm -rf ~/.config/SogouPY.usersrm -rf ~/.config/SogouPYfctix 安装cairo-dock很实用的小工具（模拟mac的dock栏）1234sudo add-apt-repository ppa:cairo-dock-team/ppasudo apt-get updatesudo apt-get install cairo-dock# 启动命令 cairo-dock 第一次打开会提示是否开启OpenGl，我的电脑上面测试开启过后会出问题，我选择不开启，如果以后想开启，可以使用cairo-dock -c（不开启） / cario-dock -o（开启OpenGl）切换 安装shadowsocks-qt5“纸飞机”这个东西还是必须要有的啊，没有这个东西感觉整个人都不好了1234sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5#启动命令 ss-qt5 安装proxychain4ss-qt5 是桌面级应用，尽管连上代理，命令行还是无法通过代理上网。proxychain 可以完美解决命令行不能使用代理的问题1234git clone https://github.com/rofl0r/proxychains-ng.gitcd proxychains-ng./configure(sudo) make &amp;&amp; make instal 安装完毕后，需要手动新建配置文件12345sudo vi /etc/proxychains.conf#然后填入以下内容[ProxyList]socks5 127.0.0.1 1080 使用方法1proxychains (sudo) 需要执行的命令 ... 为firefox 和 chrome 安装flash首先进入系统设置–&gt;软件和更行–&gt;其它软件–&gt;勾选Canonial合作伙伴，然后运行命令1sudo apt install adobe-flashplugin 安装atomatom 是一款非常优秀的编辑器，不解释。由于官方网站没有提供32bit deb包（64bit无视），因此需要自行通过ppa安装123sudo add-apt-repository ppa:webupd8team/atom sudo apt-get update sudo apt-get install atom 安装nodejs 最新版（较新版）到https://nodejs.org/download/release/v7.5.0/ 去下载最新的nodejs包我这里选择node-v7.5.0-linux-x86.tar.gz下载下来过后，执行1234tar -zxvf node-v7.5.0-linux-x86.tar.gzcp node-v7.5.0-linux-x86 /opt/node-v7.5.0sudo ln -s /opt/node-v7.5.0/bin/node /usr/local/bin/nodesudo ln -s /opt/node-v7.5.0/bin/npm /usr/local/bin/npm 现在可以使用node 和npm命令了，接下载就是配置npm 全局安装路径了（可以不用配置）12npm config set prefix \"/home/johnny/.npm-global/\"# 使用npm config get prefix 可以查看全局安装路径 还没完，这时候npm install xxx -g 过后会发现执行xxx命令无效。比如说安装hexo， npm install hexo -g成功后，执行hexo却提示command not found。配置一下环境变量就可以解决这个问题1echo -e \"export PATH=$(npm prefix -g)/bin:$PATH\" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc 安装oracle-jdk首先下载jdk然后解压,我将他解压到了~/jdk1.8.0_121/,如果只是当前用户用的话，直接改.bashrc文件中配置环境变量就好了，不过建议写到/etc/profile中123456vi ~/.bashrc#在最末尾加入export JAVA_HOME=/home/johnny/jdk1.8.0_121 ## 这里要注意目录要换成自己解压的jdk 目录export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 然后12source ~/.bashrcjava -version 就可以看到java版本已经变成安装的版本了 安卓开发环境搭建https://developer.android.com/studio/index.html下载好sdk，解压到自己想解压的目录，我这里解压到/home/johnny/sdk然后配置环境变量 12345vi ~/.bashrc#在最末尾加入export ANDROID_HOME=/home/johnny/Johnny/sdkexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-tools 现在执行android 就可以打开sdk 管理器了，下载自己需要的package就行了。但是由于现在的sdk版本高了，默认是64位，所以32位ubuntu在运行adb命令时就会报错。file adb 也可以看到adb是64位的。解决方案就是将platform-tools 替换成32位的老版本，替换后就可以成功运行adb命令了 最终效果","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}]},{"title":"react-native学习日记之ListView二","date":"2017-02-08T05:35:04.000Z","path":"2017/02/08/react学习日记之ListView二/","text":"用listView实现九宫格效果这次时照着es6的写法写的，es6和es5的写法有很多地方不一样123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, ListView, TouchableOpacity, Image&#125; from 'react-native';import Dimensions from 'Dimensions';const listData = [ &#123; src:'a', desc:'第一张' &#125;, &#123; src:'b', desc:'第二张' &#125;, &#123; src:'c', desc:'第三张' &#125;, &#123; src:'d', desc:'第四张' &#125;, &#123; src:'e', desc:'第五张' &#125;, &#123; src:'b', desc:'第二张' &#125;, &#123; src:'c', desc:'第三张' &#125;, &#123; src:'d', desc:'第四张' &#125;, &#123; src:'e', desc:'第五张' &#125;];// 获取屏幕宽高var &#123;width,height&#125; = Dimensions.get('window');var cols = 3; //3列var cellWidth = 100,cellHeight = 100;var vMargin = (width-cols*cellWidth)/(cols+1); //九宫格横向margin算法var hMargin = 20; //九宫格纵向marginexport default class ListViewjiugongge extends Component &#123; constructor(props) &#123; super(props); const ds = new ListView.DataSource(&#123;rowHasChanged:(r1,r2)=&gt;r1!==r2&#125;); this.state = &#123; dataSource: ds.cloneWithRows(listData) &#125; &#125; render() &#123; return ( &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this.renderRow&#125; // renderSeparator=&#123;(sectionID,rowID,adjacentRowHighlighted)=&gt;&#123; // console.log(sectionID,rowID,adjacentRowHighlighted); // return( // &lt;View key=&#123;`$&#123;sectionID&#125;-$&#123;rowID&#125;`&#125; // style=&#123;&#123;height:90,width:1,backgroundColor:adjacentRowHighlighted?'blue':'red'&#125;&#125; // &gt;&lt;/View&gt; // ) // &#125;&#125; contentContainerStyle=&#123;styles.listViewStyle&#125; /&gt; ); &#125; renderRow(owData,sectionID,rowID,highlightRow) &#123; return( &lt;TouchableOpacity activeOpacity=&#123;0.5&#125; onPress=&#123;()=&gt;&#123;highlightRow(sectionID,rowID)&#125;&#125;&gt; &lt;View style=&#123;styles.cellViewStyle&#125;&gt; &#123;/*图片src*/&#125; &lt;Image source=&#123;&#123;uri:owData.src&#125;&#125; style=&#123;&#123;width:100,height:100,borderRadius:50&#125;&#125;/&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; listViewStyle: &#123; flexDirection:'row', flexWrap:'wrap', alignItems:'flex-start' &#125;, cellViewStyle: &#123; marginLeft:vMargin, marginTop: hMargin &#125;, descStyle: &#123; // flexDirection:'row', // alignItems:'center' &#125;&#125;);AppRegistry.registerComponent('ListViewjiugongge', () =&gt; ListViewjiugongge);","tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"react-native学习日记之ListView","date":"2017-02-08T05:35:04.000Z","path":"2017/02/08/react学习日记之ListView/","text":"react-native ListView DOC ListView 基本用法1234567891011121314151617181920212223242526//es5 写法var ListViewDemo = React.createClass(&#123; getInitialState() &#123; // 设置初始值 // 1.1 设置数据源 var ds = new ListView.DataSource(&#123;rowHasChanged:(r1,r2)=&gt;r1!==r2&#125;); // 1.2 设置返回数据 return &#123; //listData 为一个数组格式 dataSource: ds.cloneWithRows(listData) &#125; &#125;, // 设置render函数 render() &#123; return ( &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this.renderListView&#125; //this.renderListView后不加括号表示默认接受所有参数（owData，sectionID...) /&gt; ); &#125;, renderListView(owData, sectionID, rowID, highlightRow) &#123; //renderRow 回调函数 &#125;&#125; 12345678910111213141516171819//es6 写法class MyComponent extends Component &#123; constructor() &#123; super(); const ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;); this.state = &#123; dataSource: ds.cloneWithRows(listData), &#125;; &#125; render() &#123; return ( &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this.renderListView&#125; /&gt; ); &#125;&#125; 完整demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * Sample React Native App * https://github.com/facebook/react-native * @flow */import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, ListView, Image, TouchableOpacity, Alert&#125; from 'react-native';var listData = [ &#123; src:'a', desc:'第一张' &#125;, &#123; src:'b', desc:'第二张' &#125;, &#123; src:'c', desc:'第三张' &#125;, &#123; src:'d', desc:'第四张' &#125;, &#123; src:'e', desc:'第五张' &#125;, &#123; src:'b', desc:'第二张' &#125;, &#123; src:'c', desc:'第三张' &#125;, &#123; src:'d', desc:'第四张' &#125;, &#123; src:'e', desc:'第五张' &#125;];var ListViewDemo = React.createClass(&#123; getInitialState() &#123; // 设置初始值 // 1.1 设置数据源 var ds = new ListView.DataSource(&#123;rowHasChanged:(r1,r2)=&gt;r1!==r2&#125;); // 1.2 设置返回数据 return &#123; dataSource: ds.cloneWithRows(listData) &#125; &#125;, // 设置render函数 render() &#123; return ( &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this.renderListView&#125; renderSeparator=&#123;(sectionID, rowID, adjacentRowHighlighted)=&gt;&#123; return ( &lt;View key=&#123;`$&#123;sectionID&#125;-$&#123;rowID&#125;`&#125; style=&#123;&#123;height:1,backgroundColor:adjacentRowHighlighted?'blue':'red'&#125;&#125; &gt;&lt;/View&gt; ); &#125;&#125; /&gt; ); &#125;, // renderRow的回调函数 renderListView(owData, sectionID, rowID, highlightRow) &#123; return ( &lt;TouchableOpacity activeOpacity=&#123;0.5&#125; onPress=&#123;()=&gt;highlightRow(sectionID,rowID)&#125;&gt; &lt;View style=&#123;styles.cellViewStyle&#125;&gt; &#123;/*左边的图片src*/&#125; &lt;Image source=&#123;&#123;uri:owData.src&#125;&#125; style=&#123;&#123;width:100,height:100,marginRight:15,borderRadius:50&#125;&#125;/&gt; &#123;/*右边的图片描述desc*/&#125; &lt;View style=&#123;styles.descStyle&#125;&gt; &lt;Text&gt; &#123;owData.desc&#125; &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ); &#125;&#125;)const styles = StyleSheet.create(&#123; cellViewStyle: &#123; // borderBottomWidth: 1, // borderBottomColor: '#eeeeee', flexDirection:'row', &#125;, descStyle: &#123; flexDirection:'row', alignItems:'center' &#125;&#125;);AppRegistry.registerComponent('ListViewDemo', () =&gt; ListViewDemo); 运行效果初始状态。onPress触发后 注意cloneWithRows接受一个数组renderRow，hightlightRow &amp; renderSeparator renderRow 的回调函数可以接受4个参数，分别是数据，区块id，行id，highlightRow回调函数 其中hightlightRow的用法文档里面写的不是很明白。搜了一下，发现是这样用的 http://stackoverflow.com/questions/36000842/how-do-i-call-highlightrow-of-listview-renderrow 大致过程是这样的，如果触发了hightlightRow(sectionID,rowID)函数，则会将该sectionID，rowID相应的单元行的标记为highlighted。而renderSeparator会检查每一个row的相邻row的highlight情况，也就是adjacentRowHighlighted 的真假。adjacentRowHighlighted默认为false 文档对renderSeparator的解释 renderSeparator function #(sectionID, rowID, adjacentRowHighlighted) =&gt; renderable如果提供了此属性，一个可渲染的组件会被渲染在每一行下面，除了小节标题的前面的最后一行。在其上方的小节ID和行ID，以及邻近的行是否被高亮会作为参数传递进来。 (sectionID, rowID, adjacentRowHighlighted) =&gt; renderableIf provided, a renderable component to be rendered as the separator below each row but not the last row if there is a section header below. Take a sectionID and rowID of the row above and whether its adjacent row is highlighted. 123&lt;View key=&#123;`$&#123;sectionID&#125;-$&#123;rowID&#125;`&#125; style=&#123;&#123;height:1,backgroundColor:adjacentRowHighlighted?'blue':'red'&#125;&#125;&gt;&lt;/View&gt; 这块代码表示了当adjacentRowHighlighted为true时，该view（分割线）的颜色为蓝色。 另外 http://wiki.jikexueyuan.com/project/react-native/image.htm 1&lt;Image source=&#123;&#123;uri:...&#125;&#125;/&gt; 中的uri的用法","tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"react-native 学习日记之ScrollView","date":"2017-02-07T09:44:54.000Z","path":"2017/02/07/学习日记/","text":"使用ScrollView 实现轮播效果还行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View, Image, ScrollView&#125; from 'react-native';var Images = require('./images.json');import Dimensions from 'Dimensions';import TimerMixin from 'react-timer-mixin';var width = Dimensions.get('window').width;var ScrollViewProject = React.createClass(&#123; mixins:[TimerMixin], getInitialState() &#123; return &#123; currentPage:0 &#125; &#125;, render() &#123; return( &lt;View style=&#123;styles.container&#125;&gt; &#123;/*轮播*/&#125; &lt;ScrollView ref='scrollView' horizontal=&#123;true&#125; showsHorizontalScrollIndicator=&#123;false&#125; pagingEnabled=&#123;true&#125; onScroll=&#123;(e)=&gt;this.changeIndicators(e)&#125; onScrollBeginDrag=&#123;this.onScrollBeginDrag&#125; onScrollEndDrag=&#123;this.onScrollEndDrag&#125; &gt; &#123;this.renderAllImage()&#125; &lt;/ScrollView&gt; &#123;/*轮播指示器*/&#125; &lt;View style=&#123;styles.indicators&#125;&gt; &#123;this.renderIndicator()&#125; &lt;/View&gt; &lt;/View&gt; ); &#125;, componentDidMount() &#123; // this.setInterval( // ()=&gt;console.log('testTimeout'),1000 // ); // 开启定时器 this.startTimer(); &#125;, renderAllImage() &#123; var allImgs = []; var imgData = Images.data; var srcs = [ require(\"./imgs/a.jpg\"), require(\"./imgs/b.jpg\"), require(\"./imgs/c.jpg\"), require(\"./imgs/d.jpg\"), require(\"./imgs/e.jpg\") ]; for(let i=0;i&lt;imgData.length;i++) &#123; allImgs.push( &lt;Image key=&#123;i&#125; source=&#123;srcs[i]&#125; style=&#123;&#123;width:width,height:180&#125;&#125; /&gt; ) &#125; return allImgs; &#125;, renderIndicator() &#123; var indicators = []; for(let i=0;i&lt;5;i++) &#123; let style = (i==this.state.currentPage)?&#123;color:'#ffff00'&#125;:&#123;color:'#ffffff'&#125; indicators.push( &lt;Text key=&#123;i&#125; style=&#123;[&#123;fontSize:30,marginLeft:5&#125;,style]&#125;&gt;&amp;bull;&lt;/Text&gt; ) &#125; return indicators; &#125;, changeIndicators(e) &#123; var offsetX = e.nativeEvent.contentOffset.x; this.setState(&#123; currentPage:Math.floor(offsetX/width) &#125;) &#125;, // 设置轮播自动滚动 startTimer() &#123; // 1. 拿到scrollView var scrollView = this.refs.scrollView; // 2. 添加定时器 this.timer = this.setInterval(()=&gt;&#123; // console.log('haha'); // 2.1 设置圆点 var activePage; // 2.2 判断 if(this.state.currentPage+1 &gt;=5) activePage=0; else activePage=this.state.currentPage+1; // 2.3 更新状态 this.setState(&#123; currentPage:activePage &#125;) // 2.4 让scroll滚动起来 var offsetX = activePage * width; scrollView.scrollResponderScrollTo(&#123;x:offsetX,y:0,animated:true&#125;); &#125;,1000); &#125;, // 拖动轮播时停止定时器 onScrollBeginDrag() &#123; this.clearInterval(this.timer); &#125;, // 拖动结束后打开定时器 onScrollEndDrag() &#123; this.startTimer(); &#125;&#125;);const styles = StyleSheet.create(&#123; container: &#123; // flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', // marginTop:20 &#125;, indicators: &#123; flexDirection:'row', backgroundColor:'rgba(0,0,0,0.1)', height:30, width:width, alignItems:'center', marginTop:-30 &#125;&#125;);AppRegistry.registerComponent('ScrollViewProject', () =&gt; ScrollViewProject);","tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"'Generator 执行顺序'","date":"2016-12-26T04:13:50.000Z","path":"2016/12/26/Generator/","text":"generator 不同于普通的函数，执行方式有区别 12345678function* foo() &#123; yield 1; console.log(yield);&#125;let fooObj = foo();console.log(fooObj.next());console.log(fooObj.next());console.log(fooObj.next()); 第一个fooObj.next() 返回Object {value: 1, done: false}此时fooObj指针指向的是yield 1(第一个yield) 第二次运行fooObj.next(), 指针指向console.log(yield)中的yield即第二个yeild,此时函数返回Object {value: undefined, done: false} 第三次运行fooObj.next(), 指针继续向后移动,开始执行console.log(yield)语句,由于next参数为undefined,则指定上一次(即第二次yeild)yeild为undefined所以打印出undefined 和 Object {value: undefined, done: true}","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]}]